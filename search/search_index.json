{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WyzeCam Documentation Introduction Wyzecam is a library for streaming audio and video from your wyze cameras using the wyze native firmware. That means no need to flash rtsp-specific firmware, and full support for the v3 hardware! Basic Usage Streaming video in 11 lines of code! import os import cv2 import wyzecam auth_info = wyzecam . login ( os . environ [ \"WYZE_EMAIL\" ], os . environ [ \"WYZE_PASSWORD\" ]) account = wyzecam . get_user_info ( auth_info ) camera = wyzecam . get_camera_list ( auth_info )[ 0 ] with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame_ndarray (): cv2 . imshow ( \"Video Feed\" , frame ) cv2 . waitKey ( 1 ) Features Send local commands (via WyzeIOTC class) Support for all wyze camera types (including wyzecam v3!) Uses the tutk protocol for communicating over the local network. Optional support for opencv and libav for easy decoding of the video feed! Requirements Mac or Linux (Windows untested) A copy of the TUTK C library (see installation for more details here) Installation See installation for detailed instructions.","title":"Home"},{"location":"#wyzecam-documentation","text":"","title":"WyzeCam Documentation"},{"location":"#introduction","text":"Wyzecam is a library for streaming audio and video from your wyze cameras using the wyze native firmware. That means no need to flash rtsp-specific firmware, and full support for the v3 hardware!","title":"Introduction"},{"location":"#basic-usage","text":"Streaming video in 11 lines of code! import os import cv2 import wyzecam auth_info = wyzecam . login ( os . environ [ \"WYZE_EMAIL\" ], os . environ [ \"WYZE_PASSWORD\" ]) account = wyzecam . get_user_info ( auth_info ) camera = wyzecam . get_camera_list ( auth_info )[ 0 ] with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame_ndarray (): cv2 . imshow ( \"Video Feed\" , frame ) cv2 . waitKey ( 1 )","title":"Basic Usage"},{"location":"#features","text":"Send local commands (via WyzeIOTC class) Support for all wyze camera types (including wyzecam v3!) Uses the tutk protocol for communicating over the local network. Optional support for opencv and libav for easy decoding of the video feed!","title":"Features"},{"location":"#requirements","text":"Mac or Linux (Windows untested) A copy of the TUTK C library (see installation for more details here)","title":"Requirements"},{"location":"#installation","text":"See installation for detailed instructions.","title":"Installation"},{"location":"installation/","text":"Installation Installing this library is as easy as pip install! pip install wyzecam ... almost. You will also need a copy of the shared library libIOTCAPIs_ALL.so . You will need to download this SDK , unzip it, then convert the appropriate copy of the library to a shared library, and copy the resultant .so or .dylib file to somewhere convenient. On Mac: unzip TUTK_IOTC_Platform_14W42P1.zip cd Lib/MAC/ g++ -fpic -shared -Wl,-all_load libIOTCAPIs_ALL.a -o libIOTCAPIs_ALL.dylib cp libIOTCAPIs_ALL.dylib /usr/local/lib/ On Linux: unzip TUTK_IOTC_Platform_14W42P1.zip cd Lib/Linux/x64/ g++ -fpic -shared -Wl,--whole-archive libAVAPIs.a libIOTCAPIs.a -Wl,--no-whole-archive -o libIOTCAPIs_ALL.so cp libIOTCAPIs_ALL.so /usr/local/lib/ Note: you will need to pick the appropriate architecture. On Windows: Follow guide to install Windows Subsystem for Linux Install VcXsrv Windows X Server Run the following command and add it to /etc/bash.bashrc export DISPLAY = \":0\" Follow Linux instructions to compile the shared library","title":"Installation"},{"location":"installation/#installation","text":"Installing this library is as easy as pip install! pip install wyzecam ... almost. You will also need a copy of the shared library libIOTCAPIs_ALL.so . You will need to download this SDK , unzip it, then convert the appropriate copy of the library to a shared library, and copy the resultant .so or .dylib file to somewhere convenient.","title":"Installation"},{"location":"installation/#on-mac","text":"unzip TUTK_IOTC_Platform_14W42P1.zip cd Lib/MAC/ g++ -fpic -shared -Wl,-all_load libIOTCAPIs_ALL.a -o libIOTCAPIs_ALL.dylib cp libIOTCAPIs_ALL.dylib /usr/local/lib/","title":"On Mac:"},{"location":"installation/#on-linux","text":"unzip TUTK_IOTC_Platform_14W42P1.zip cd Lib/Linux/x64/ g++ -fpic -shared -Wl,--whole-archive libAVAPIs.a libIOTCAPIs.a -Wl,--no-whole-archive -o libIOTCAPIs_ALL.so cp libIOTCAPIs_ALL.so /usr/local/lib/ Note: you will need to pick the appropriate architecture.","title":"On Linux:"},{"location":"installation/#on-windows","text":"Follow guide to install Windows Subsystem for Linux Install VcXsrv Windows X Server Run the following command and add it to /etc/bash.bashrc export DISPLAY = \":0\" Follow Linux instructions to compile the shared library","title":"On Windows:"},{"location":"reference/iotc/","text":"WyzeIOTC Wyze IOTC singleton, used to construct iotc_sessions This object should generally be used inside a context manager, i.e.: with WyzeIOTC () as wyze : with wyze . connect_and_auth ( account , camera ) as session : ... # send commands to the camera, then start streaming Attributes: Name Type Description tutk_platform_lib CDLL the underlying c library used to communicate with the wyze device; see wyzecam.tutk.tutk.load_library udp_port int the UDP port used on this machine for communication with wyze cameras on the same network max_num_av_channels int the maximum number of simultaneous sessions this object supports. version the version of the underyling tutk_platform_lib connect_and_auth ( self , account , camera ) Initialize a new iotc session with the specified camera, and account information. The result of this method should be used as a context manager, i.e. using the 'with' keyword. This allows us to automatically clean up after we're done with the session: with WyzeIOTC () as iotc : with iotc . connect_and_auth ( account , camera ) as session : ... # send configuration commands, or stream video from the session. See WyzeIOTCSession for more info. Parameters: Name Type Description Default account WyzeAccount the account object returned from wyzecam.api.get_user_info required camera WyzeCamera the camera object returned from wyzecam.api.get_camera_list required Returns: Type Description WyzeIOTCSession An object representing the Wyze IOTC Session, a WyzeIOTCSession Source code in wyzecam/iotc.py def connect_and_auth ( self , account : WyzeAccount , camera : WyzeCamera ) -> \"WyzeIOTCSession\" : \"\"\"Initialize a new iotc session with the specified camera, and account information. The result of this method should be used as a context manager, i.e. using the 'with' keyword. This allows us to automatically clean up after we're done with the session: ```python with WyzeIOTC() as iotc: with iotc.connect_and_auth(account, camera) as session: ... # send configuration commands, or stream video from the session. ``` See [WyzeIOTCSession](../iotc_session/) for more info. :param account: the account object returned from [wyzecam.api.get_user_info][] :param camera: the camera object returned from [wyzecam.api.get_camera_list][] :returns: An object representing the Wyze IOTC Session, a [WyzeIOTCSession](../iotc_session/) \"\"\" return WyzeIOTCSession ( self . tutk_platform_lib , account , camera )","title":"WyzeIOTC"},{"location":"reference/iotc/#wyzeiotc","text":"Wyze IOTC singleton, used to construct iotc_sessions This object should generally be used inside a context manager, i.e.: with WyzeIOTC () as wyze : with wyze . connect_and_auth ( account , camera ) as session : ... # send commands to the camera, then start streaming Attributes: Name Type Description tutk_platform_lib CDLL the underlying c library used to communicate with the wyze device; see wyzecam.tutk.tutk.load_library udp_port int the UDP port used on this machine for communication with wyze cameras on the same network max_num_av_channels int the maximum number of simultaneous sessions this object supports. version the version of the underyling tutk_platform_lib","title":"WyzeIOTC"},{"location":"reference/iotc/#wyzecam.iotc.WyzeIOTC.connect_and_auth","text":"Initialize a new iotc session with the specified camera, and account information. The result of this method should be used as a context manager, i.e. using the 'with' keyword. This allows us to automatically clean up after we're done with the session: with WyzeIOTC () as iotc : with iotc . connect_and_auth ( account , camera ) as session : ... # send configuration commands, or stream video from the session. See WyzeIOTCSession for more info. Parameters: Name Type Description Default account WyzeAccount the account object returned from wyzecam.api.get_user_info required camera WyzeCamera the camera object returned from wyzecam.api.get_camera_list required Returns: Type Description WyzeIOTCSession An object representing the Wyze IOTC Session, a WyzeIOTCSession Source code in wyzecam/iotc.py def connect_and_auth ( self , account : WyzeAccount , camera : WyzeCamera ) -> \"WyzeIOTCSession\" : \"\"\"Initialize a new iotc session with the specified camera, and account information. The result of this method should be used as a context manager, i.e. using the 'with' keyword. This allows us to automatically clean up after we're done with the session: ```python with WyzeIOTC() as iotc: with iotc.connect_and_auth(account, camera) as session: ... # send configuration commands, or stream video from the session. ``` See [WyzeIOTCSession](../iotc_session/) for more info. :param account: the account object returned from [wyzecam.api.get_user_info][] :param camera: the camera object returned from [wyzecam.api.get_camera_list][] :returns: An object representing the Wyze IOTC Session, a [WyzeIOTCSession](../iotc_session/) \"\"\" return WyzeIOTCSession ( self . tutk_platform_lib , account , camera )","title":"connect_and_auth()"},{"location":"reference/iotc_session/","text":"WyzeIOTCSession An IOTC session object, used for communicating with Wyze cameras This is constructed from a WyzeIOTC object: with WyzeIOTC () as wyze : with wyze . connect_and_auth ( account , camera ) as session : ... # send configuration commands, or stream video However, you can construct it manually, which can be helpful if you intend to set a different frame size or bitrate than the defaults: with WyzeIOTCSession ( lib , account , camera , bitrate = tutk . BITRATE_SD ) ... Note: WyzeIOTCSession is intended to be used as a context manager. Otherwise, you will need to manually tell the session to connect and authenticate, by calling session._connect() followed by session._auth(), and session._disconnect() when you're ready to disconnect the session. Attributes: Name Type Description tutk_platform_lib CDLL The underlying c library (from tutk.load_library ) account WyzeAccount A WyzeAccount instance, see api.get_user_info camera WyzeCamera A WyzeCamera instance, see api.get_camera_list preferred_frame_size int The preferred size of the video stream returned by the camera. See wyzecam.tutk.tutk.FRAME_SIZE_1080P . preferred_bitrate int The preferred bitrate of the video stream returned by the camera. See wyzecam.tutk.tutk.BITRATE_HD . session_id Optional[c_int] The id of this session, once connected. av_chan_id Optional[c_int] The AV channel of this session, once connected. state WyzeIOTCSessionState The current connection state of this session. See WyzeIOTCSessionState . __init__ ( self , tutk_platform_lib , account , camera , frame_size = 0 , bitrate = 120 ) special Construct a wyze iotc session Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library ) required account WyzeAccount A WyzeAccount instance, see api.get_user_info required camera WyzeCamera A WyzeCamera instance, see api.get_camera_list required frame_size int Configures the size of the video stream returned by the camera. See wyzecam.tutk.tutk.FRAME_SIZE_1080P . 0 bitrate int Configures the bitrate of the video stream returned by the camera. See wyzecam.tutk.tutk.BITRATE_HD . 120 Source code in wyzecam/iotc.py def __init__ ( self , tutk_platform_lib : CDLL , account : WyzeAccount , camera : WyzeCamera , frame_size : int = tutk . FRAME_SIZE_1080P , bitrate : int = tutk . BITRATE_HD , ) -> None : \"\"\"Construct a wyze iotc session :param tutk_platform_lib: The underlying c library (from [tutk.load_library][wyzecam.tutk.tutk.load_library]) :param account: A [WyzeAccount][wyzecam.api_models.WyzeAccount] instance, see [api.get_user_info][wyzecam.api.get_user_info] :param camera: A [WyzeCamera][wyzecam.api_models.WyzeCamera] instance, see [api.get_camera_list][wyzecam.api.get_camera_list] :param frame_size: Configures the size of the video stream returned by the camera. See [wyzecam.tutk.tutk.FRAME_SIZE_1080P][]. :param bitrate: Configures the bitrate of the video stream returned by the camera. See [wyzecam.tutk.tutk.BITRATE_HD][]. \"\"\" self . tutk_platform_lib : CDLL = tutk_platform_lib self . account : WyzeAccount = account self . camera : WyzeCamera = camera self . session_id : Optional [ c_int ] = None self . av_chan_id : Optional [ c_int ] = None self . state : WyzeIOTCSessionState = WyzeIOTCSessionState . DISCONNECTED self . preferred_frame_size : int = frame_size self . preferred_bitrate : int = bitrate iotctrl_mux ( self ) Constructs a new TutkIOCtrlMux for this session Use this to send configuration messages, such as change the cameras resolution. Note that you either should treat the result of this as a context manager (using with), or call start_listening() explicitly on the result. This starts a separate thread listening for the responses from the camera. with session . ioctrl_mux () as mux : msg = tutk_protocol . K10056SetResolvingBit ( tutk . FRAME_SIZE_1080P , tutk . BITRATE_SD ) future = mux . send_ioctl ( msg ) assert future . result () == True , \"Change bitrate failed!\" Source code in wyzecam/iotc.py def iotctrl_mux ( self ) -> TutkIOCtrlMux : \"\"\"Constructs a new TutkIOCtrlMux for this session Use this to send configuration messages, such as change the cameras resolution. Note that you either should treat the result of this as a context manager (using with), or call start_listening() explicitly on the result. This starts a separate thread listening for the responses from the camera. ```python with session.ioctrl_mux() as mux: msg = tutk_protocol.K10056SetResolvingBit( tutk.FRAME_SIZE_1080P, tutk.BITRATE_SD) future = mux.send_ioctl(msg) assert future.result() == True, \"Change bitrate failed!\" ``` \"\"\" assert self . av_chan_id is not None , \"Please call _connect() first!\" return TutkIOCtrlMux ( self . tutk_platform_lib , self . av_chan_id ) recv_video_data ( self ) A generator for returning raw video frames! By iterating over the return value of this function, you will get raw video frame data in the form of a bytes object. This is convenient for accessing the raw video data without doing the work of decoding or transcoding the actual video feed. If you want to save the video to disk, display it, or otherwise process the video, I highly recommend using recv_video_frame or recv_video_frame_nparray instead of this function. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. Note that the format of this data is either raw h264 or HVEC H265 video. You will have to introspect the frame_info object to determine the format! with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_data (): # do something with the video data! :) In order to use this, you will need to install PyAV . Returns: Type Description Iterator[Tuple[Optional[bytes], Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a PyAV VideoFrame ), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_data ( self , ) -> Iterator [ Tuple [ Optional [ bytes ], Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ] ] ]: \"\"\"A generator for returning raw video frames! By iterating over the return value of this function, you will get raw video frame data in the form of a bytes object. This is convenient for accessing the raw video data without doing the work of decoding or transcoding the actual video feed. If you want to save the video to disk, display it, or otherwise process the video, I highly recommend using `recv_video_frame` or `recv_video_frame_nparray` instead of this function. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. Note that the format of this data is either raw h264 or HVEC H265 video. You will have to introspect the frame_info object to determine the format! ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_data(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a [PyAV VideoFrame](https://pyav.org/docs/stable/api/video.html#av.video.frame.VideoFrame)), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" assert self . av_chan_id is not None , \"Please call _connect() first!\" while True : errno , frame_data , frame_info , frame_idx = tutk . av_recv_frame_data ( self . tutk_platform_lib , self . av_chan_id ) if errno < 0 : if errno == tutk . AV_ER_DATA_NOREADY : time . sleep ( 1.0 / 40 ) continue elif errno == tutk . AV_ER_INCOMPLETE_FRAME : warnings . warn ( \"Received incomplete frame\" ) continue elif errno == tutk . AV_ER_LOSED_THIS_FRAME : warnings . warn ( \"Lost frame\" ) continue else : raise tutk . TutkError ( errno ) assert frame_info is not None , \"Got no frame info without an error!\" if frame_info . frame_size != self . preferred_frame_size : if frame_info . frame_size < 2 : logger . debug ( f \"skipping smaller frame at start of stream (frame_size= { frame_info . frame_size } )\" ) continue else : # wyze doorbell has weird rotated image sizes. if frame_info . frame_size - 3 != self . preferred_frame_size : continue yield frame_data , frame_info recv_video_frame ( self ) A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a PyAV VideoFrame object. This is convenient for recording the video to disk. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame (): # do something with the video data! :) In order to use this, you will need to install PyAV . Returns: Type Description Iterator[Tuple[av.VideoFrame, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a PyAV VideoFrame ), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_frame ( self , ) -> Iterator [ Tuple [ \"av.VideoFrame\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ] ] ]: \"\"\"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a PyAV VideoFrame object. This is convenient for recording the video to disk. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_frame(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a [PyAV VideoFrame](https://pyav.org/docs/stable/api/video.html#av.video.frame.VideoFrame)), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" if av is None : raise RuntimeError ( \"recv_video_frame requires PyAv to parse video frames. \" \"Install with `pip install av` and try again.\" ) codec = None for frame_data , frame_info in self . recv_video_data (): if codec is None : codec = self . _av_codec_from_frameinfo ( frame_info ) packets = codec . parse ( frame_data ) for packet in packets : frames = codec . decode ( packet ) for frame in frames : yield frame , frame_info recv_video_frame_ndarray ( self ) A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a numpy array (suitable for matplotlib.imshow or cv2.imshow . The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame_ndarray (): # do something with the video data! :) In order to use this, you will need to install PyAV and numpy . Returns: Type Description Iterator[Tuple[np.ndarray, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a numpy array), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_frame_ndarray ( self , ) -> Iterator [ Tuple [ \"np.ndarray\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ]] ]: \"\"\"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a numpy array (suitable for [matplotlib.imshow](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html) or [cv2.imshow](https://docs.opencv.org/master/dd/d43/tutorial_py_video_display.html). The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_frame_ndarray(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/) and [numpy](https://numpy.org/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a numpy array), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" if np is None : raise RuntimeError ( \"recv_video_frame_ndarray requires numpy to convert to a numpy array. \" \"Install with `pip install numpy` and try again.\" ) for frame , frame_info in self . recv_video_frame (): img = frame . to_ndarray ( format = \"bgr24\" ) if frame_info . frame_size in ( 3 , 4 ): img = np . rot90 ( img , 3 ) img = np . ascontiguousarray ( img , dtype = np . uint8 ) yield img , frame_info recv_video_frame_ndarray_with_stats ( self , stat_window_size = 210 , draw_stats = ' {width} x {height} {kilobytes_per_second} kB/s {frames_per_second} FPS' ) Does everything recv_video_frame_ndarray does, but also computes a number of useful / interesting debug metrics including effective framerate, bitrate, and frame size information. Optionally, if you specify a format string to the draw_stats function, this information will be used to draw a line of text onto the image in the top-right corner with this debug information. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info , frame_stats ) in sess . recv_video_frame_ndarray_with_stats (): # do something with the video data! :) This method gives you an additional 'frame_stats' value every frame, which is a dict with the following keys: \"bytes_per_second\" \"kilobytes_per_second\" \"window_duration\" \"frames_per_second\" \"width\" \"height\" This dictionary is available in the draw_stats string as arguments to a python str.format() call, allowing you to quickly change the debug string in the top corner of the video. In order to use this, you will need to install PyAV , numpy , and PyOpenCV . Parameters: Name Type Description Default stat_window_size int the number of consecutive frames to use as the window function for computing the above metrics. The larger the window size, the longer period over which the metrics are averaged. Note that this method is not performant for very large window sizes. 210 draw_stats Optional[str] if specified, this python format() string is used to draw some debug text in the upper right hand corner. '{width}x{height} {kilobytes_per_second} kB/s {frames_per_second} FPS' Returns: Type Description Iterator[Tuple[np.ndarray, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct], Dict[str, int]]] A generator, which when iterated over, yields a 3-tuple containing the decoded image (as a numpy array), metadata about the frame (in the form of a tutk.FrameInfoStruct ), and some performance statistics (in the form of a dict). Source code in wyzecam/iotc.py def recv_video_frame_ndarray_with_stats ( self , stat_window_size : int = 210 , draw_stats : Optional [ str ] = \" {width} x {height} {kilobytes_per_second} kB/s {frames_per_second} FPS\" , ) -> Iterator [ Tuple [ \"np.ndarray\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ], Dict [ str , int ], ] ]: \"\"\" Does everything recv_video_frame_ndarray does, but also computes a number of useful / interesting debug metrics including effective framerate, bitrate, and frame size information. Optionally, if you specify a format string to the `draw_stats` function, this information will be used to draw a line of text onto the image in the top-right corner with this debug information. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info, frame_stats) in sess.recv_video_frame_ndarray_with_stats(): # do something with the video data! :) ``` This method gives you an additional 'frame_stats' value every frame, which is a dict with the following keys: - \"bytes_per_second\" - \"kilobytes_per_second\" - \"window_duration\" - \"frames_per_second\" - \"width\" - \"height\" This dictionary is available in the draw_stats string as arguments to a python str.format() call, allowing you to quickly change the debug string in the top corner of the video. In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/), [numpy](https://numpy.org/), and [PyOpenCV](https://pypi.org/project/opencv-python/). :param stat_window_size: the number of consecutive frames to use as the window function for computing the above metrics. The larger the window size, the longer period over which the metrics are averaged. Note that this method is not performant for very large window sizes. :param draw_stats: if specified, this python format() string is used to draw some debug text in the upper right hand corner. :returns: A generator, which when iterated over, yields a 3-tuple containing the decoded image (as a numpy array), metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]), and some performance statistics (in the form of a dict). \"\"\" stat_window = [] for frame_ndarray , frame_info in self . recv_video_frame_ndarray (): stat_window . append ( frame_info ) if len ( stat_window ) > stat_window_size : stat_window = stat_window [ len ( stat_window ) - stat_window_size :] if len ( stat_window ) > 1 : stat_window_start = ( stat_window [ 0 ] . timestamp + stat_window [ 0 ] . timestamp_ms / 1_000_000 ) stat_window_end = ( stat_window [ - 1 ] . timestamp + stat_window [ - 1 ] . timestamp_ms / 1_000_000 ) stat_window_duration = stat_window_end - stat_window_start if stat_window_duration <= 0 : # wyze doorbell doesn't support timestamp_ms; workaround: stat_window_duration = ( len ( stat_window ) / stat_window [ - 1 ] . framerate ) stat_window_total_size = sum ( b . frame_len for b in stat_window [: - 1 ] ) # skip the last reading bytes_per_second = int ( stat_window_total_size / stat_window_duration ) frames_per_second = int ( len ( stat_window ) / stat_window_duration ) else : bytes_per_second = 0 stat_window_duration = 0 frames_per_second = 0 stats = { \"bytes_per_second\" : bytes_per_second , \"kilobytes_per_second\" : int ( bytes_per_second / 1000 ), \"window_duration\" : stat_window_duration , \"frames_per_second\" : frames_per_second , \"width\" : frame_ndarray . shape [ 1 ], \"height\" : frame_ndarray . shape [ 0 ], } if draw_stats : text = draw_stats . format ( ** stats ) cv2 . putText ( frame_ndarray , text , ( 50 , 50 ), cv2 . FONT_HERSHEY_DUPLEX , 1 , ( 0 , 0 , 0 ), 2 , cv2 . LINE_AA , ) cv2 . putText ( frame_ndarray , text , ( 50 , 50 ), cv2 . FONT_HERSHEY_DUPLEX , 1 , ( 255 , 255 , 255 ), 1 , cv2 . LINE_AA , ) yield frame_ndarray , frame_info , stats session_check ( self ) Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. Returns: Type Description SInfoStruct A tutk.SInfoStruct Source code in wyzecam/iotc.py def session_check ( self ) -> tutk . SInfoStruct : \"\"\"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. :returns: A [`tutk.SInfoStruct`][wyzecam.tutk.tutk.SInfoStruct] \"\"\" assert ( self . session_id is not None ), \"Please call _connect() before session_check()\" errcode , sess_info = tutk . iotc_session_check ( self . tutk_platform_lib , self . session_id ) if errcode < 0 : raise tutk . TutkError ( errcode ) return sess_info","title":"WyzeIOTCSession"},{"location":"reference/iotc_session/#wyzeiotcsession","text":"An IOTC session object, used for communicating with Wyze cameras This is constructed from a WyzeIOTC object: with WyzeIOTC () as wyze : with wyze . connect_and_auth ( account , camera ) as session : ... # send configuration commands, or stream video However, you can construct it manually, which can be helpful if you intend to set a different frame size or bitrate than the defaults: with WyzeIOTCSession ( lib , account , camera , bitrate = tutk . BITRATE_SD ) ... Note: WyzeIOTCSession is intended to be used as a context manager. Otherwise, you will need to manually tell the session to connect and authenticate, by calling session._connect() followed by session._auth(), and session._disconnect() when you're ready to disconnect the session. Attributes: Name Type Description tutk_platform_lib CDLL The underlying c library (from tutk.load_library ) account WyzeAccount A WyzeAccount instance, see api.get_user_info camera WyzeCamera A WyzeCamera instance, see api.get_camera_list preferred_frame_size int The preferred size of the video stream returned by the camera. See wyzecam.tutk.tutk.FRAME_SIZE_1080P . preferred_bitrate int The preferred bitrate of the video stream returned by the camera. See wyzecam.tutk.tutk.BITRATE_HD . session_id Optional[c_int] The id of this session, once connected. av_chan_id Optional[c_int] The AV channel of this session, once connected. state WyzeIOTCSessionState The current connection state of this session. See WyzeIOTCSessionState .","title":"WyzeIOTCSession"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.__init__","text":"Construct a wyze iotc session Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library ) required account WyzeAccount A WyzeAccount instance, see api.get_user_info required camera WyzeCamera A WyzeCamera instance, see api.get_camera_list required frame_size int Configures the size of the video stream returned by the camera. See wyzecam.tutk.tutk.FRAME_SIZE_1080P . 0 bitrate int Configures the bitrate of the video stream returned by the camera. See wyzecam.tutk.tutk.BITRATE_HD . 120 Source code in wyzecam/iotc.py def __init__ ( self , tutk_platform_lib : CDLL , account : WyzeAccount , camera : WyzeCamera , frame_size : int = tutk . FRAME_SIZE_1080P , bitrate : int = tutk . BITRATE_HD , ) -> None : \"\"\"Construct a wyze iotc session :param tutk_platform_lib: The underlying c library (from [tutk.load_library][wyzecam.tutk.tutk.load_library]) :param account: A [WyzeAccount][wyzecam.api_models.WyzeAccount] instance, see [api.get_user_info][wyzecam.api.get_user_info] :param camera: A [WyzeCamera][wyzecam.api_models.WyzeCamera] instance, see [api.get_camera_list][wyzecam.api.get_camera_list] :param frame_size: Configures the size of the video stream returned by the camera. See [wyzecam.tutk.tutk.FRAME_SIZE_1080P][]. :param bitrate: Configures the bitrate of the video stream returned by the camera. See [wyzecam.tutk.tutk.BITRATE_HD][]. \"\"\" self . tutk_platform_lib : CDLL = tutk_platform_lib self . account : WyzeAccount = account self . camera : WyzeCamera = camera self . session_id : Optional [ c_int ] = None self . av_chan_id : Optional [ c_int ] = None self . state : WyzeIOTCSessionState = WyzeIOTCSessionState . DISCONNECTED self . preferred_frame_size : int = frame_size self . preferred_bitrate : int = bitrate","title":"__init__()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.iotctrl_mux","text":"Constructs a new TutkIOCtrlMux for this session Use this to send configuration messages, such as change the cameras resolution. Note that you either should treat the result of this as a context manager (using with), or call start_listening() explicitly on the result. This starts a separate thread listening for the responses from the camera. with session . ioctrl_mux () as mux : msg = tutk_protocol . K10056SetResolvingBit ( tutk . FRAME_SIZE_1080P , tutk . BITRATE_SD ) future = mux . send_ioctl ( msg ) assert future . result () == True , \"Change bitrate failed!\" Source code in wyzecam/iotc.py def iotctrl_mux ( self ) -> TutkIOCtrlMux : \"\"\"Constructs a new TutkIOCtrlMux for this session Use this to send configuration messages, such as change the cameras resolution. Note that you either should treat the result of this as a context manager (using with), or call start_listening() explicitly on the result. This starts a separate thread listening for the responses from the camera. ```python with session.ioctrl_mux() as mux: msg = tutk_protocol.K10056SetResolvingBit( tutk.FRAME_SIZE_1080P, tutk.BITRATE_SD) future = mux.send_ioctl(msg) assert future.result() == True, \"Change bitrate failed!\" ``` \"\"\" assert self . av_chan_id is not None , \"Please call _connect() first!\" return TutkIOCtrlMux ( self . tutk_platform_lib , self . av_chan_id )","title":"iotctrl_mux()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.recv_video_data","text":"A generator for returning raw video frames! By iterating over the return value of this function, you will get raw video frame data in the form of a bytes object. This is convenient for accessing the raw video data without doing the work of decoding or transcoding the actual video feed. If you want to save the video to disk, display it, or otherwise process the video, I highly recommend using recv_video_frame or recv_video_frame_nparray instead of this function. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. Note that the format of this data is either raw h264 or HVEC H265 video. You will have to introspect the frame_info object to determine the format! with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_data (): # do something with the video data! :) In order to use this, you will need to install PyAV . Returns: Type Description Iterator[Tuple[Optional[bytes], Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a PyAV VideoFrame ), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_data ( self , ) -> Iterator [ Tuple [ Optional [ bytes ], Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ] ] ]: \"\"\"A generator for returning raw video frames! By iterating over the return value of this function, you will get raw video frame data in the form of a bytes object. This is convenient for accessing the raw video data without doing the work of decoding or transcoding the actual video feed. If you want to save the video to disk, display it, or otherwise process the video, I highly recommend using `recv_video_frame` or `recv_video_frame_nparray` instead of this function. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. Note that the format of this data is either raw h264 or HVEC H265 video. You will have to introspect the frame_info object to determine the format! ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_data(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a [PyAV VideoFrame](https://pyav.org/docs/stable/api/video.html#av.video.frame.VideoFrame)), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" assert self . av_chan_id is not None , \"Please call _connect() first!\" while True : errno , frame_data , frame_info , frame_idx = tutk . av_recv_frame_data ( self . tutk_platform_lib , self . av_chan_id ) if errno < 0 : if errno == tutk . AV_ER_DATA_NOREADY : time . sleep ( 1.0 / 40 ) continue elif errno == tutk . AV_ER_INCOMPLETE_FRAME : warnings . warn ( \"Received incomplete frame\" ) continue elif errno == tutk . AV_ER_LOSED_THIS_FRAME : warnings . warn ( \"Lost frame\" ) continue else : raise tutk . TutkError ( errno ) assert frame_info is not None , \"Got no frame info without an error!\" if frame_info . frame_size != self . preferred_frame_size : if frame_info . frame_size < 2 : logger . debug ( f \"skipping smaller frame at start of stream (frame_size= { frame_info . frame_size } )\" ) continue else : # wyze doorbell has weird rotated image sizes. if frame_info . frame_size - 3 != self . preferred_frame_size : continue yield frame_data , frame_info","title":"recv_video_data()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.recv_video_frame","text":"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a PyAV VideoFrame object. This is convenient for recording the video to disk. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame (): # do something with the video data! :) In order to use this, you will need to install PyAV . Returns: Type Description Iterator[Tuple[av.VideoFrame, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a PyAV VideoFrame ), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_frame ( self , ) -> Iterator [ Tuple [ \"av.VideoFrame\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ] ] ]: \"\"\"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a PyAV VideoFrame object. This is convenient for recording the video to disk. The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_frame(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a [PyAV VideoFrame](https://pyav.org/docs/stable/api/video.html#av.video.frame.VideoFrame)), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" if av is None : raise RuntimeError ( \"recv_video_frame requires PyAv to parse video frames. \" \"Install with `pip install av` and try again.\" ) codec = None for frame_data , frame_info in self . recv_video_data (): if codec is None : codec = self . _av_codec_from_frameinfo ( frame_info ) packets = codec . parse ( frame_data ) for packet in packets : frames = codec . decode ( packet ) for frame in frames : yield frame , frame_info","title":"recv_video_frame()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.recv_video_frame_ndarray","text":"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a numpy array (suitable for matplotlib.imshow or cv2.imshow . The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See tutk.FrameInfoStruct for more details about the contents of this object. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info ) in sess . recv_video_frame_ndarray (): # do something with the video data! :) In order to use this, you will need to install PyAV and numpy . Returns: Type Description Iterator[Tuple[np.ndarray, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct]]] A generator, which when iterated over, yields a tuple containing the decoded image (as a numpy array), as well as metadata about the frame (in the form of a tutk.FrameInfoStruct ). Source code in wyzecam/iotc.py def recv_video_frame_ndarray ( self , ) -> Iterator [ Tuple [ \"np.ndarray\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ]] ]: \"\"\"A generator for returning decoded video frames! By iterating over the return value of this function, you will conveniently get nicely decoded frames in the form of a numpy array (suitable for [matplotlib.imshow](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html) or [cv2.imshow](https://docs.opencv.org/master/dd/d43/tutorial_py_video_display.html). The second item in the tuple returned by this function, 'frame_info', is a useful set of metadata about the frame as returned by the camera. See [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct] for more details about the contents of this object. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info) in sess.recv_video_frame_ndarray(): # do something with the video data! :) ``` In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/) and [numpy](https://numpy.org/). :returns: A generator, which when iterated over, yields a tuple containing the decoded image (as a numpy array), as well as metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]). \"\"\" if np is None : raise RuntimeError ( \"recv_video_frame_ndarray requires numpy to convert to a numpy array. \" \"Install with `pip install numpy` and try again.\" ) for frame , frame_info in self . recv_video_frame (): img = frame . to_ndarray ( format = \"bgr24\" ) if frame_info . frame_size in ( 3 , 4 ): img = np . rot90 ( img , 3 ) img = np . ascontiguousarray ( img , dtype = np . uint8 ) yield img , frame_info","title":"recv_video_frame_ndarray()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.recv_video_frame_ndarray_with_stats","text":"Does everything recv_video_frame_ndarray does, but also computes a number of useful / interesting debug metrics including effective framerate, bitrate, and frame size information. Optionally, if you specify a format string to the draw_stats function, this information will be used to draw a line of text onto the image in the top-right corner with this debug information. with wyzecam . WyzeIOTC () as wyze_iotc : with wyze_iotc . connect_and_auth ( account , camera ) as sess : for ( frame , frame_info , frame_stats ) in sess . recv_video_frame_ndarray_with_stats (): # do something with the video data! :) This method gives you an additional 'frame_stats' value every frame, which is a dict with the following keys: \"bytes_per_second\" \"kilobytes_per_second\" \"window_duration\" \"frames_per_second\" \"width\" \"height\" This dictionary is available in the draw_stats string as arguments to a python str.format() call, allowing you to quickly change the debug string in the top corner of the video. In order to use this, you will need to install PyAV , numpy , and PyOpenCV . Parameters: Name Type Description Default stat_window_size int the number of consecutive frames to use as the window function for computing the above metrics. The larger the window size, the longer period over which the metrics are averaged. Note that this method is not performant for very large window sizes. 210 draw_stats Optional[str] if specified, this python format() string is used to draw some debug text in the upper right hand corner. '{width}x{height} {kilobytes_per_second} kB/s {frames_per_second} FPS' Returns: Type Description Iterator[Tuple[np.ndarray, Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct], Dict[str, int]]] A generator, which when iterated over, yields a 3-tuple containing the decoded image (as a numpy array), metadata about the frame (in the form of a tutk.FrameInfoStruct ), and some performance statistics (in the form of a dict). Source code in wyzecam/iotc.py def recv_video_frame_ndarray_with_stats ( self , stat_window_size : int = 210 , draw_stats : Optional [ str ] = \" {width} x {height} {kilobytes_per_second} kB/s {frames_per_second} FPS\" , ) -> Iterator [ Tuple [ \"np.ndarray\" , Union [ tutk . FrameInfoStruct , tutk . FrameInfo3Struct ], Dict [ str , int ], ] ]: \"\"\" Does everything recv_video_frame_ndarray does, but also computes a number of useful / interesting debug metrics including effective framerate, bitrate, and frame size information. Optionally, if you specify a format string to the `draw_stats` function, this information will be used to draw a line of text onto the image in the top-right corner with this debug information. ```python with wyzecam.WyzeIOTC() as wyze_iotc: with wyze_iotc.connect_and_auth(account, camera) as sess: for (frame, frame_info, frame_stats) in sess.recv_video_frame_ndarray_with_stats(): # do something with the video data! :) ``` This method gives you an additional 'frame_stats' value every frame, which is a dict with the following keys: - \"bytes_per_second\" - \"kilobytes_per_second\" - \"window_duration\" - \"frames_per_second\" - \"width\" - \"height\" This dictionary is available in the draw_stats string as arguments to a python str.format() call, allowing you to quickly change the debug string in the top corner of the video. In order to use this, you will need to install [PyAV](https://pyav.org/docs/stable/), [numpy](https://numpy.org/), and [PyOpenCV](https://pypi.org/project/opencv-python/). :param stat_window_size: the number of consecutive frames to use as the window function for computing the above metrics. The larger the window size, the longer period over which the metrics are averaged. Note that this method is not performant for very large window sizes. :param draw_stats: if specified, this python format() string is used to draw some debug text in the upper right hand corner. :returns: A generator, which when iterated over, yields a 3-tuple containing the decoded image (as a numpy array), metadata about the frame (in the form of a [tutk.FrameInfoStruct][wyzecam.tutk.tutk.FrameInfoStruct]), and some performance statistics (in the form of a dict). \"\"\" stat_window = [] for frame_ndarray , frame_info in self . recv_video_frame_ndarray (): stat_window . append ( frame_info ) if len ( stat_window ) > stat_window_size : stat_window = stat_window [ len ( stat_window ) - stat_window_size :] if len ( stat_window ) > 1 : stat_window_start = ( stat_window [ 0 ] . timestamp + stat_window [ 0 ] . timestamp_ms / 1_000_000 ) stat_window_end = ( stat_window [ - 1 ] . timestamp + stat_window [ - 1 ] . timestamp_ms / 1_000_000 ) stat_window_duration = stat_window_end - stat_window_start if stat_window_duration <= 0 : # wyze doorbell doesn't support timestamp_ms; workaround: stat_window_duration = ( len ( stat_window ) / stat_window [ - 1 ] . framerate ) stat_window_total_size = sum ( b . frame_len for b in stat_window [: - 1 ] ) # skip the last reading bytes_per_second = int ( stat_window_total_size / stat_window_duration ) frames_per_second = int ( len ( stat_window ) / stat_window_duration ) else : bytes_per_second = 0 stat_window_duration = 0 frames_per_second = 0 stats = { \"bytes_per_second\" : bytes_per_second , \"kilobytes_per_second\" : int ( bytes_per_second / 1000 ), \"window_duration\" : stat_window_duration , \"frames_per_second\" : frames_per_second , \"width\" : frame_ndarray . shape [ 1 ], \"height\" : frame_ndarray . shape [ 0 ], } if draw_stats : text = draw_stats . format ( ** stats ) cv2 . putText ( frame_ndarray , text , ( 50 , 50 ), cv2 . FONT_HERSHEY_DUPLEX , 1 , ( 0 , 0 , 0 ), 2 , cv2 . LINE_AA , ) cv2 . putText ( frame_ndarray , text , ( 50 , 50 ), cv2 . FONT_HERSHEY_DUPLEX , 1 , ( 255 , 255 , 255 ), 1 , cv2 . LINE_AA , ) yield frame_ndarray , frame_info , stats","title":"recv_video_frame_ndarray_with_stats()"},{"location":"reference/iotc_session/#wyzecam.iotc.WyzeIOTCSession.session_check","text":"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. Returns: Type Description SInfoStruct A tutk.SInfoStruct Source code in wyzecam/iotc.py def session_check ( self ) -> tutk . SInfoStruct : \"\"\"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. :returns: A [`tutk.SInfoStruct`][wyzecam.tutk.tutk.SInfoStruct] \"\"\" assert ( self . session_id is not None ), \"Please call _connect() before session_check()\" errcode , sess_info = tutk . iotc_session_check ( self . tutk_platform_lib , self . session_id ) if errcode < 0 : raise tutk . TutkError ( errcode ) return sess_info","title":"session_check()"},{"location":"reference/iotc_session_state/","text":"WyzeIOTCSessionState An enum describing the possible states of a WyzeIOTCSession AUTHENTICATING Attempting to authenticate AUTHENTICATION_FAILED Authentication failed, no longer connected AUTHENTICATION_SUCCEEDED Fully connected and authenticated AV_CONNECTING Currently attempting to connect the AV session CONNECTED Fully connected to the camera, but have not yet attempted to authenticate CONNECTING_FAILED Connection failed, no longer connected DISCONNECTED Not yet connected IOTC_CONNECTING Currently attempting to connect the IOTC session","title":"WyzeIOTCSessionState"},{"location":"reference/iotc_session_state/#wyzeiotcsessionstate","text":"An enum describing the possible states of a WyzeIOTCSession","title":"WyzeIOTCSessionState"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.AUTHENTICATING","text":"Attempting to authenticate","title":"AUTHENTICATING"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.AUTHENTICATION_FAILED","text":"Authentication failed, no longer connected","title":"AUTHENTICATION_FAILED"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.AUTHENTICATION_SUCCEEDED","text":"Fully connected and authenticated","title":"AUTHENTICATION_SUCCEEDED"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.AV_CONNECTING","text":"Currently attempting to connect the AV session","title":"AV_CONNECTING"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.CONNECTED","text":"Fully connected to the camera, but have not yet attempted to authenticate","title":"CONNECTED"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.CONNECTING_FAILED","text":"Connection failed, no longer connected","title":"CONNECTING_FAILED"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.DISCONNECTED","text":"Not yet connected","title":"DISCONNECTED"},{"location":"reference/iotc_session_state/#wyzecam.iotc.WyzeIOTCSessionState.IOTC_CONNECTING","text":"Currently attempting to connect the IOTC session","title":"IOTC_CONNECTING"},{"location":"reference/tutk/tutk/","text":"Attributes AV_ER_DATA_NOREADY An error raised when the client asks for data not yet available on the camera. AV_ER_INCOMPLETE_FRAME An error sent during video streaming if the camera wasn't able to send a complete frame. AV_ER_LOSED_THIS_FRAME An error sent during video streaming if the frame was lost in transmission. AV_ER_SESSION_CLOSE_BY_REMOTE An error raised when the camera closes the connection. AV_ER_TIMEOUT An error raised when the AV library times out. BITRATE_360P The bitrate used by the \"360P\" setting in the app. Approx 30 KB/s. BITRATE_HD The bitrate used by the \"HD\" setting in the app. Approx 120 KB/s. BITRATE_SD The bitrate used by the \"SD\" setting in the app. Approx 60 KB/s. BITRATE_SUPER_HD A bitrate higher than the \"HD\" setting in the app. Approx 150 KB/s. BITRATE_SUPER_SUPER_HD A bitrate higher than the \"HD\" setting in the app. Approx 240 KB/s. FRAME_SIZE_1080P Represents the size of the video stream sent back from the server; 1080P or 1920x1080 pixels. FRAME_SIZE_360P Represents the size of the video stream sent back from the server; 360P or 640x360 pixels. FRAME_SIZE_DOORBELL_HD Represents the size of the video stream sent back from the server; portrait 1296 x 1728. FRAME_SIZE_DOORBELL_SD Represents the size of the video stream sent back from the server; portrait 480 x 640. Classes FrameInfoStruct A struct recieved on every video frame, with lots of useful information about the frame sent by the camera. Attributes: Name Type Description codec_id int 78: h264 80: h265 is_keyframe int True if the frame being described is a keyframe cam_index int The index of the camera online_num int Not clear framerate int framerate of the video frame, in frames / second frame_size int frame size of the video frame, either FRAME_SIZE_1080P or FRAME_SIZE_360P bitrate int bitrate of the video frame, as configured. timestamp_ms int the millisecond component of the timestamp. timestamp int the seconds component of the timestamp. frame_len int the size of the data sent by the camera, in bytes. frame_no int the current frame number as recorded by the camera ac_mac_addr str unknown n_play_token int unknown SInfoStruct Result of iotc_session_check(), this struct holds a bunch of diagnostic data about the state of the connection to the camera. Attributes: Name Type Description mode int 0: P2P mode, 1: Relay mode, 2: LAN mode c_or_d int 0: As a Client, 1: As a Device uid str The UID of the device. remote_ip str The IP address of remote site used during this IOTC session. remote_port int The port number of remote site used during this IOTC session. tx_packet_count int The total packets sent from the device and the client during this IOTC session. rx_packet_count int The total packets received in the device and the client during this IOTC session iotc_version int version number of the IOTC device. vendor_id int id of the vendor of the device product_id int id of the product of the device group_id int id of the group of the device nat_type int The remote NAT type. is_secure int 0: The IOTC session is in non-secure mode, 1: The IOTC session is in secure mode Functions av_client_set_max_buf_size ( tutk_platform_lib , size ) Set the maximum video frame buffer used in AV client. AV client sets the maximum video frame buffer by this function. The size of video frame buffer will affect the streaming fluency. The default size of video frame buffer is 1MB. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required size int The maximum video frame buffer, in unit of kilo-byte required Source code in wyzecam/tutk/tutk.py def av_client_set_max_buf_size ( tutk_platform_lib : CDLL , size : int ) -> None : \"\"\"Set the maximum video frame buffer used in AV client. AV client sets the maximum video frame buffer by this function. The size of video frame buffer will affect the streaming fluency. The default size of video frame buffer is 1MB. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param size: The maximum video frame buffer, in unit of kilo-byte \"\"\" tutk_platform_lib . avClientSetMaxBufSize ( c_int ( size )) av_client_start ( tutk_platform_lib , session_id , username , password , timeout_secs , channel_id ) Start an AV client. Start an AV client by providing view account and password. It shall pass the authentication of the AV server before receiving AV data. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required session_id Union[int, ctypes.c_int] The session ID of the IOTC session to start AV client required username bytes The view account for authentication required password bytes The view password for authentication required timeout_secs int The timeout for this function in unit of second Specify it as 0 will make this AV client try connection once and this process will exit immediately if not connection is unsuccessful. required channel_id int The channel ID of the channel to start AV client required Returns: Type Description Tuple[ctypes.c_int, ctypes.c_uint] returns a tuple of two values: - av_chan_id: AV channel ID if return value >= 0; error code if return value < 0 - pn_serv_type: The user-defined service type set when an AV server starts. Can be NULL. Source code in wyzecam/tutk/tutk.py def av_client_start ( tutk_platform_lib : CDLL , session_id : Union [ int , c_int ], username : bytes , password : bytes , timeout_secs : int , channel_id : int , ) -> typing . Tuple [ c_int , c_uint ]: \"\"\"Start an AV client. Start an AV client by providing view account and password. It shall pass the authentication of the AV server before receiving AV data. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param session_id: The session ID of the IOTC session to start AV client :param username: The view account for authentication :param password: The view password for authentication :param timeout_secs: The timeout for this function in unit of second Specify it as 0 will make this AV client try connection once and this process will exit immediately if not connection is unsuccessful. :param channel_id: The channel ID of the channel to start AV client :return: returns a tuple of two values: - av_chan_id: AV channel ID if return value >= 0; error code if return value < 0 - pn_serv_type: The user-defined service type set when an AV server starts. Can be NULL. \"\"\" n_timeout = c_uint ( timeout_secs ) user_defined_service_type = c_uint () chan_id = c_uint8 ( channel_id ) av_chan_id = tutk_platform_lib . avClientStart ( session_id , c_char_p ( username ), c_char_p ( password ), n_timeout , pointer ( user_defined_service_type ), chan_id , ) return av_chan_id , user_defined_service_type av_client_stop ( tutk_platform_lib , av_chan_id ) Stop an AV client. An AV client stop AV channel by this function if this channel is no longer required. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to be stopped required Source code in wyzecam/tutk/tutk.py def av_client_stop ( tutk_platform_lib : CDLL , av_chan_id : c_int ) -> None : \"\"\"Stop an AV client. An AV client stop AV channel by this function if this channel is no longer required. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to be stopped \"\"\" tutk_platform_lib . avClientStop ( av_chan_id ) av_deinitialize ( tutk_platform_lib ) Deinitialize AV module. This function will deinitialize AV module. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required Returns: Type Description int Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def av_deinitialize ( tutk_platform_lib : CDLL ) -> int : \"\"\"Deinitialize AV module. This function will deinitialize AV module. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :return: Error code if return value < 0 \"\"\" errno : int = tutk_platform_lib . avDeInitialize () return errno av_initialize ( tutk_platform_lib , max_num_channels = 1 ) Initialize AV module. This function is used by AV servers or AV clients to initialize AV module and shall be called before any AV module related function is invoked. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required max_num_channels Optional[int] The max number of AV channels. If it is specified less than 1, AV will set max number of AV channels as 1. 1 Returns: Type Description int The actual maximum number of AV channels to be set. Error code if return value < 0. Source code in wyzecam/tutk/tutk.py def av_initialize ( tutk_platform_lib : CDLL , max_num_channels : Optional [ int ] = 1 ) -> int : \"\"\"Initialize AV module. This function is used by AV servers or AV clients to initialize AV module and shall be called before any AV module related function is invoked. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param max_num_channels: The max number of AV channels. If it is specified less than 1, AV will set max number of AV channels as 1. :return:The actual maximum number of AV channels to be set. Error code if return value < 0. \"\"\" max_chans : int = tutk_platform_lib . avInitialize ( max_num_channels ) return max_chans av_recv_frame_data ( tutk_platform_lib , av_chan_id ) A new version AV client receives frame data from an AV server. An AV client uses this function to receive frame data from AV server Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to recv data on. required Returns: Type Description Tuple[int, Optional[bytes], Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct], Optional[int]] a 4-tuple of errno, frame_data, frame_info, and frame_index Source code in wyzecam/tutk/tutk.py def av_recv_frame_data ( tutk_platform_lib : CDLL , av_chan_id : c_int ) -> typing . Tuple [ int , Optional [ bytes ], Optional [ Union [ FrameInfoStruct , FrameInfo3Struct ]], Optional [ int ], ]: \"\"\"A new version AV client receives frame data from an AV server. An AV client uses this function to receive frame data from AV server :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to recv data on. :return: a 4-tuple of errno, frame_data, frame_info, and frame_index \"\"\" frame_data_max_len = 5 * 1024 * 1024 frame_data_actual_len = c_int () frame_data_expected_len = c_int () frame_data = ( c_char * frame_data_max_len )() frame_info_actual_len = c_int () frame_index = c_uint () frame_info_max_len = max ( sizeof ( FrameInfo3Struct ), sizeof ( FrameInfoStruct )) frame_info = ( c_char * frame_info_max_len )() errno = tutk_platform_lib . avRecvFrameData2 ( av_chan_id , pointer ( frame_data ), c_int ( frame_data_max_len ), pointer ( frame_data_actual_len ), pointer ( frame_data_expected_len ), pointer ( frame_info ), c_int ( frame_info_max_len ), pointer ( frame_info_actual_len ), pointer ( frame_index ), ) if errno < 0 : return errno , None , None , None else : frame_data_actual : bytes = frame_data [: frame_data_actual_len . value ] # type: ignore frame_info_actual : Union [ FrameInfoStruct , FrameInfo3Struct ] if frame_info_actual_len . value == sizeof ( FrameInfo3Struct ): frame_info_actual = FrameInfo3Struct . from_buffer ( frame_info ) elif frame_info_actual_len . value == sizeof ( FrameInfoStruct ): frame_info_actual = FrameInfoStruct . from_buffer ( frame_info ) else : from wyzecam.tutk.tutk_protocol import TutkWyzeProtocolError raise TutkWyzeProtocolError ( f \"Unknown frame info structure format! len= { frame_info_actual_len } \" ) return ( 0 , frame_data_actual , frame_info_actual , frame_index . value , ) av_recv_io_ctrl ( tutk_platform_lib , av_chan_id , timeout_ms ) Receive AV IO control. This function is used by AV servers or AV clients to receive a AV IO control. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to be stopped required timeout_ms int the number of milliseconds to wait before timing out required Returns: Type Description Tuple[int, int, Optional[List[bytes]]] a tuple of (the length of the io_ctrl received (or error number), the io_ctrl_type, and the data in bytes) Source code in wyzecam/tutk/tutk.py def av_recv_io_ctrl ( tutk_platform_lib : CDLL , av_chan_id : c_int , timeout_ms : int ) -> typing . Tuple [ int , int , Optional [ typing . List [ bytes ]]]: \"\"\"Receive AV IO control. This function is used by AV servers or AV clients to receive a AV IO control. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to be stopped :param timeout_ms: the number of milliseconds to wait before timing out :returns: a tuple of (the length of the io_ctrl received (or error number), the io_ctrl_type, and the data in bytes) \"\"\" pn_io_ctrl_type = c_uint () ctl_data_len = 1024 * 1024 ctl_data = ( c_char * ctl_data_len )() actual_len = tutk_platform_lib . avRecvIOCtrl ( av_chan_id , pointer ( pn_io_ctrl_type ), ctl_data , c_int ( ctl_data_len ), c_int ( timeout_ms ), ) return ( actual_len , pn_io_ctrl_type . value , ctl_data [ 0 : actual_len ] if actual_len > 0 else None , ) iotc_connect_by_uid ( tutk_platform_lib , p2p_id ) Used by a client to connect a device. This function is for a client to connect a device by specifying the UID of that device. If connection is established with the help of IOTC servers, the IOTC session ID will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required p2p_id str The UID of a device that client wants to connect required Returns: Type Description c_int IOTC session ID if return value >= 0, error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_connect_by_uid ( tutk_platform_lib : CDLL , p2p_id : str ) -> c_int : \"\"\"Used by a client to connect a device. This function is for a client to connect a device by specifying the UID of that device. If connection is established with the help of IOTC servers, the IOTC session ID will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param p2p_id: The UID of a device that client wants to connect :return: IOTC session ID if return value >= 0, error code if return value < 0 \"\"\" session_id : c_int = tutk_platform_lib . IOTC_Connect_ByUID ( c_char_p ( p2p_id . encode ( \"ascii\" )) ) return session_id iotc_connect_by_uid_parallel ( tutk_platform_lib , p2p_id , session_id ) Used by a client to connect a device and bind to a specified session ID. This function is for a client to connect a device by specifying the UID of that device, and bind to a tutk_platform_free session ID from IOTC_Get_SessionID(). If connection is established with the help of IOTC servers, the IOTC_ER_NoERROR will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. If this function is called by multiple threads, the connections will be processed concurrently. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required p2p_id str The UID of a device that client wants to connect required session_id c_int The Session ID got from IOTC_Get_SessionID() the connection should bind to. required Returns: Type Description c_int IOTC session ID if return value >= 0, error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_connect_by_uid_parallel ( tutk_platform_lib : CDLL , p2p_id : str , session_id : c_int ) -> c_int : \"\"\"Used by a client to connect a device and bind to a specified session ID. This function is for a client to connect a device by specifying the UID of that device, and bind to a tutk_platform_free session ID from IOTC_Get_SessionID(). If connection is established with the help of IOTC servers, the IOTC_ER_NoERROR will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. If this function is called by multiple threads, the connections will be processed concurrently. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param p2p_id: The UID of a device that client wants to connect :param session_id: The Session ID got from IOTC_Get_SessionID() the connection should bind to. :return: IOTC session ID if return value >= 0, error code if return value < 0 \"\"\" resultant_session_id : c_int = tutk_platform_lib . IOTC_Connect_ByUID_Parallel ( c_char_p ( p2p_id . encode ( \"ascii\" )), session_id ) return resultant_session_id iotc_connect_stop_by_session_id ( tutk_platform_lib , session_id ) Used by a client to stop a specific session connecting a device. This function is for a client to stop connecting a device. Since IOTC_Connect_ByUID_Parallel() is a block processes, that means the client will have to wait for the return of these functions before executing sequential instructions. In some cases, users may want the client to stop connecting immediately by this function in another thread before the return of connection process. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required session_id c_int The Session ID got from IOTC_Get_SessionID() the connection should bind to. required Returns: Type Description c_int Error code if return value < 0, otherwise 0 if successful Source code in wyzecam/tutk/tutk.py def iotc_connect_stop_by_session_id ( tutk_platform_lib : CDLL , session_id : c_int ) -> c_int : \"\"\" Used by a client to stop a specific session connecting a device. This function is for a client to stop connecting a device. Since IOTC_Connect_ByUID_Parallel() is a block processes, that means the client will have to wait for the return of these functions before executing sequential instructions. In some cases, users may want the client to stop connecting immediately by this function in another thread before the return of connection process. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param session_id: The Session ID got from IOTC_Get_SessionID() the connection should bind to. :return: Error code if return value < 0, otherwise 0 if successful \"\"\" errno : c_int = tutk_platform_lib . IOTC_Connect_Stop_BySID ( session_id ) return errno iotc_deinitialize ( tutk_platform_lib ) Deinitialize IOTC module. This function will deinitialize IOTC module. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required Returns: Type Description c_int Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_deinitialize ( tutk_platform_lib : CDLL ) -> c_int : \"\"\"Deinitialize IOTC module. This function will deinitialize IOTC module. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :return: Error code if return value < 0 \"\"\" errno : c_int = tutk_platform_lib . IOTC_DeInitialize () return errno iotc_get_session_id ( tutk_platform_lib ) Used by a client to get a tutk_platform_free session ID. This function is for a client to get a tutk_platform_free session ID used for a parameter of iotc_connect_by_uid_parallel() Source code in wyzecam/tutk/tutk.py def iotc_get_session_id ( tutk_platform_lib : CDLL ) -> c_int : \"\"\"Used by a client to get a tutk_platform_free session ID. This function is for a client to get a tutk_platform_free session ID used for a parameter of iotc_connect_by_uid_parallel() \"\"\" session_id : c_int = tutk_platform_lib . IOTC_Get_SessionID () return session_id iotc_get_version ( tutk_platform_lib ) Get the version of IOTC module. This function returns the version of IOTC module. Source code in wyzecam/tutk/tutk.py def iotc_get_version ( tutk_platform_lib : CDLL ) -> int : \"\"\"Get the version of IOTC module. This function returns the version of IOTC module. \"\"\" version = c_uint32 () tutk_platform_lib . IOTC_Get_Version ( pointer ( version )) return version . value iotc_initialize ( tutk_platform_lib , udp_port = 0 ) Initialize IOTC module. This function is used by devices or clients to initialize IOTC module and shall be called before any IOTC module related function is invoked except for IOTC_Set_Max_Session_Number(). The different between this function and IOTC_Initialize() is this function uses following steps to connect masters (1) IP addresses of master (2) if fails to connect in step 1, resolve predefined domain name of masters (3) try to connect again with the resolved IP address of step 2 if IP is resolved successfully. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required udp_port int Specify a UDP port. Random UDP port is used if it is specified as 0. 0 Returns: Type Description int 0 if successful, Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_initialize ( tutk_platform_lib : CDLL , udp_port : int = 0 ) -> int : \"\"\"Initialize IOTC module. This function is used by devices or clients to initialize IOTC module and shall be called before any IOTC module related function is invoked except for IOTC_Set_Max_Session_Number(). The different between this function and IOTC_Initialize() is this function uses following steps to connect masters (1) IP addresses of master (2) if fails to connect in step 1, resolve predefined domain name of masters (3) try to connect again with the resolved IP address of step 2 if IP is resolved successfully. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param udp_port: Specify a UDP port. Random UDP port is used if it is specified as 0. :return: 0 if successful, Error code if return value < 0 \"\"\" errno : int = tutk_platform_lib . IOTC_Initialize2 ( udp_port ) return errno iotc_session_check ( tutk_platform_lib , session_id ) Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required session_id c_int The session ID of the IOTC session to be checked required Returns: Type Description Tuple[int, wyzecam.tutk.tutk.SInfoStruct] The session info of specified IOTC session Source code in wyzecam/tutk/tutk.py def iotc_session_check ( tutk_platform_lib : CDLL , session_id : c_int ) -> typing . Tuple [ int , SInfoStruct ]: \"\"\"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param session_id: The session ID of the IOTC session to be checked :return: The session info of specified IOTC session \"\"\" sess_info = SInfoStruct () err_code = tutk_platform_lib . IOTC_Session_Check ( session_id , pointer ( sess_info ) ) return err_code , sess_info iotc_session_close ( tutk_platform_lib , session_id ) Used by a device or a client to close a IOTC session. A device or a client uses this function to close a IOTC session specified by its session ID if this IOTC session is no longer required. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required session_id c_int The session ID of the IOTC session to start AV client required Source code in wyzecam/tutk/tutk.py def iotc_session_close ( tutk_platform_lib : CDLL , session_id : c_int ) -> None : \"\"\"Used by a device or a client to close a IOTC session. A device or a client uses this function to close a IOTC session specified by its session ID if this IOTC session is no longer required. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param session_id: The session ID of the IOTC session to start AV client \"\"\" tutk_platform_lib . IOTC_Session_Close ( session_id ) iotc_set_log_path ( tutk_platform_lib , path ) Set path of log file. Set the absolute path of log file Source code in wyzecam/tutk/tutk.py def iotc_set_log_path ( tutk_platform_lib : CDLL , path : str ) -> None : \"\"\"Set path of log file. Set the absolute path of log file \"\"\" tutk_platform_lib . IOTC_Set_Log_Path ( c_char_p ( path . encode ( \"ascii\" )), c_int ( 0 ) ) load_library ( shared_lib_path = None ) Load the underlying iotc library Parameters: Name Type Description Default shared_lib_path Optional[str] the path to the shared library libIOTCAPIs_ALL None Returns: Type Description CDLL the tutk_platform_lib, suitable for passing to other functions in this module Source code in wyzecam/tutk/tutk.py def load_library ( shared_lib_path : Optional [ str ] = None , ) -> CDLL : \"\"\"Load the underlying iotc library :param shared_lib_path: the path to the shared library libIOTCAPIs_ALL :return: the tutk_platform_lib, suitable for passing to other functions in this module \"\"\" if shared_lib_path is None : if pathlib . Path ( \"/usr/local/lib/libIOTCAPIs_ALL.dylib\" ) . exists (): shared_lib_path = \"/usr/local/lib/libIOTCAPIs_ALL.dylib\" if pathlib . Path ( \"/usr/local/lib/libIOTCAPIs_ALL.so\" ) . exists (): shared_lib_path = \"/usr/local/lib/libIOTCAPIs_ALL.so\" if shared_lib_path is None : raise RuntimeError ( \"Could not find libIOTCAPIs_ALL shared library. See documentation, \" \"or specify the full path as an argument to load_library().\" ) return cdll . LoadLibrary ( shared_lib_path )","title":"tutk.py"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk-attributes","text":"","title":"Attributes"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.AV_ER_DATA_NOREADY","text":"An error raised when the client asks for data not yet available on the camera.","title":"AV_ER_DATA_NOREADY"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.AV_ER_INCOMPLETE_FRAME","text":"An error sent during video streaming if the camera wasn't able to send a complete frame.","title":"AV_ER_INCOMPLETE_FRAME"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.AV_ER_LOSED_THIS_FRAME","text":"An error sent during video streaming if the frame was lost in transmission.","title":"AV_ER_LOSED_THIS_FRAME"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.AV_ER_SESSION_CLOSE_BY_REMOTE","text":"An error raised when the camera closes the connection.","title":"AV_ER_SESSION_CLOSE_BY_REMOTE"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.AV_ER_TIMEOUT","text":"An error raised when the AV library times out.","title":"AV_ER_TIMEOUT"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.BITRATE_360P","text":"The bitrate used by the \"360P\" setting in the app. Approx 30 KB/s.","title":"BITRATE_360P"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.BITRATE_HD","text":"The bitrate used by the \"HD\" setting in the app. Approx 120 KB/s.","title":"BITRATE_HD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.BITRATE_SD","text":"The bitrate used by the \"SD\" setting in the app. Approx 60 KB/s.","title":"BITRATE_SD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.BITRATE_SUPER_HD","text":"A bitrate higher than the \"HD\" setting in the app. Approx 150 KB/s.","title":"BITRATE_SUPER_HD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.BITRATE_SUPER_SUPER_HD","text":"A bitrate higher than the \"HD\" setting in the app. Approx 240 KB/s.","title":"BITRATE_SUPER_SUPER_HD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.FRAME_SIZE_1080P","text":"Represents the size of the video stream sent back from the server; 1080P or 1920x1080 pixels.","title":"FRAME_SIZE_1080P"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.FRAME_SIZE_360P","text":"Represents the size of the video stream sent back from the server; 360P or 640x360 pixels.","title":"FRAME_SIZE_360P"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.FRAME_SIZE_DOORBELL_HD","text":"Represents the size of the video stream sent back from the server; portrait 1296 x 1728.","title":"FRAME_SIZE_DOORBELL_HD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.FRAME_SIZE_DOORBELL_SD","text":"Represents the size of the video stream sent back from the server; portrait 480 x 640.","title":"FRAME_SIZE_DOORBELL_SD"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk-classes","text":"","title":"Classes"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.FrameInfoStruct","text":"A struct recieved on every video frame, with lots of useful information about the frame sent by the camera. Attributes: Name Type Description codec_id int 78: h264 80: h265 is_keyframe int True if the frame being described is a keyframe cam_index int The index of the camera online_num int Not clear framerate int framerate of the video frame, in frames / second frame_size int frame size of the video frame, either FRAME_SIZE_1080P or FRAME_SIZE_360P bitrate int bitrate of the video frame, as configured. timestamp_ms int the millisecond component of the timestamp. timestamp int the seconds component of the timestamp. frame_len int the size of the data sent by the camera, in bytes. frame_no int the current frame number as recorded by the camera ac_mac_addr str unknown n_play_token int unknown","title":"FrameInfoStruct"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.SInfoStruct","text":"Result of iotc_session_check(), this struct holds a bunch of diagnostic data about the state of the connection to the camera. Attributes: Name Type Description mode int 0: P2P mode, 1: Relay mode, 2: LAN mode c_or_d int 0: As a Client, 1: As a Device uid str The UID of the device. remote_ip str The IP address of remote site used during this IOTC session. remote_port int The port number of remote site used during this IOTC session. tx_packet_count int The total packets sent from the device and the client during this IOTC session. rx_packet_count int The total packets received in the device and the client during this IOTC session iotc_version int version number of the IOTC device. vendor_id int id of the vendor of the device product_id int id of the product of the device group_id int id of the group of the device nat_type int The remote NAT type. is_secure int 0: The IOTC session is in non-secure mode, 1: The IOTC session is in secure mode","title":"SInfoStruct"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk-functions","text":"","title":"Functions"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_client_set_max_buf_size","text":"Set the maximum video frame buffer used in AV client. AV client sets the maximum video frame buffer by this function. The size of video frame buffer will affect the streaming fluency. The default size of video frame buffer is 1MB. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required size int The maximum video frame buffer, in unit of kilo-byte required Source code in wyzecam/tutk/tutk.py def av_client_set_max_buf_size ( tutk_platform_lib : CDLL , size : int ) -> None : \"\"\"Set the maximum video frame buffer used in AV client. AV client sets the maximum video frame buffer by this function. The size of video frame buffer will affect the streaming fluency. The default size of video frame buffer is 1MB. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param size: The maximum video frame buffer, in unit of kilo-byte \"\"\" tutk_platform_lib . avClientSetMaxBufSize ( c_int ( size ))","title":"av_client_set_max_buf_size()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_client_start","text":"Start an AV client. Start an AV client by providing view account and password. It shall pass the authentication of the AV server before receiving AV data. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required session_id Union[int, ctypes.c_int] The session ID of the IOTC session to start AV client required username bytes The view account for authentication required password bytes The view password for authentication required timeout_secs int The timeout for this function in unit of second Specify it as 0 will make this AV client try connection once and this process will exit immediately if not connection is unsuccessful. required channel_id int The channel ID of the channel to start AV client required Returns: Type Description Tuple[ctypes.c_int, ctypes.c_uint] returns a tuple of two values: - av_chan_id: AV channel ID if return value >= 0; error code if return value < 0 - pn_serv_type: The user-defined service type set when an AV server starts. Can be NULL. Source code in wyzecam/tutk/tutk.py def av_client_start ( tutk_platform_lib : CDLL , session_id : Union [ int , c_int ], username : bytes , password : bytes , timeout_secs : int , channel_id : int , ) -> typing . Tuple [ c_int , c_uint ]: \"\"\"Start an AV client. Start an AV client by providing view account and password. It shall pass the authentication of the AV server before receiving AV data. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param session_id: The session ID of the IOTC session to start AV client :param username: The view account for authentication :param password: The view password for authentication :param timeout_secs: The timeout for this function in unit of second Specify it as 0 will make this AV client try connection once and this process will exit immediately if not connection is unsuccessful. :param channel_id: The channel ID of the channel to start AV client :return: returns a tuple of two values: - av_chan_id: AV channel ID if return value >= 0; error code if return value < 0 - pn_serv_type: The user-defined service type set when an AV server starts. Can be NULL. \"\"\" n_timeout = c_uint ( timeout_secs ) user_defined_service_type = c_uint () chan_id = c_uint8 ( channel_id ) av_chan_id = tutk_platform_lib . avClientStart ( session_id , c_char_p ( username ), c_char_p ( password ), n_timeout , pointer ( user_defined_service_type ), chan_id , ) return av_chan_id , user_defined_service_type","title":"av_client_start()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_client_stop","text":"Stop an AV client. An AV client stop AV channel by this function if this channel is no longer required. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to be stopped required Source code in wyzecam/tutk/tutk.py def av_client_stop ( tutk_platform_lib : CDLL , av_chan_id : c_int ) -> None : \"\"\"Stop an AV client. An AV client stop AV channel by this function if this channel is no longer required. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to be stopped \"\"\" tutk_platform_lib . avClientStop ( av_chan_id )","title":"av_client_stop()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_deinitialize","text":"Deinitialize AV module. This function will deinitialize AV module. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required Returns: Type Description int Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def av_deinitialize ( tutk_platform_lib : CDLL ) -> int : \"\"\"Deinitialize AV module. This function will deinitialize AV module. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :return: Error code if return value < 0 \"\"\" errno : int = tutk_platform_lib . avDeInitialize () return errno","title":"av_deinitialize()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_initialize","text":"Initialize AV module. This function is used by AV servers or AV clients to initialize AV module and shall be called before any AV module related function is invoked. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required max_num_channels Optional[int] The max number of AV channels. If it is specified less than 1, AV will set max number of AV channels as 1. 1 Returns: Type Description int The actual maximum number of AV channels to be set. Error code if return value < 0. Source code in wyzecam/tutk/tutk.py def av_initialize ( tutk_platform_lib : CDLL , max_num_channels : Optional [ int ] = 1 ) -> int : \"\"\"Initialize AV module. This function is used by AV servers or AV clients to initialize AV module and shall be called before any AV module related function is invoked. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param max_num_channels: The max number of AV channels. If it is specified less than 1, AV will set max number of AV channels as 1. :return:The actual maximum number of AV channels to be set. Error code if return value < 0. \"\"\" max_chans : int = tutk_platform_lib . avInitialize ( max_num_channels ) return max_chans","title":"av_initialize()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_recv_frame_data","text":"A new version AV client receives frame data from an AV server. An AV client uses this function to receive frame data from AV server Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to recv data on. required Returns: Type Description Tuple[int, Optional[bytes], Union[wyzecam.tutk.tutk.FrameInfoStruct, wyzecam.tutk.tutk.FrameInfo3Struct], Optional[int]] a 4-tuple of errno, frame_data, frame_info, and frame_index Source code in wyzecam/tutk/tutk.py def av_recv_frame_data ( tutk_platform_lib : CDLL , av_chan_id : c_int ) -> typing . Tuple [ int , Optional [ bytes ], Optional [ Union [ FrameInfoStruct , FrameInfo3Struct ]], Optional [ int ], ]: \"\"\"A new version AV client receives frame data from an AV server. An AV client uses this function to receive frame data from AV server :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to recv data on. :return: a 4-tuple of errno, frame_data, frame_info, and frame_index \"\"\" frame_data_max_len = 5 * 1024 * 1024 frame_data_actual_len = c_int () frame_data_expected_len = c_int () frame_data = ( c_char * frame_data_max_len )() frame_info_actual_len = c_int () frame_index = c_uint () frame_info_max_len = max ( sizeof ( FrameInfo3Struct ), sizeof ( FrameInfoStruct )) frame_info = ( c_char * frame_info_max_len )() errno = tutk_platform_lib . avRecvFrameData2 ( av_chan_id , pointer ( frame_data ), c_int ( frame_data_max_len ), pointer ( frame_data_actual_len ), pointer ( frame_data_expected_len ), pointer ( frame_info ), c_int ( frame_info_max_len ), pointer ( frame_info_actual_len ), pointer ( frame_index ), ) if errno < 0 : return errno , None , None , None else : frame_data_actual : bytes = frame_data [: frame_data_actual_len . value ] # type: ignore frame_info_actual : Union [ FrameInfoStruct , FrameInfo3Struct ] if frame_info_actual_len . value == sizeof ( FrameInfo3Struct ): frame_info_actual = FrameInfo3Struct . from_buffer ( frame_info ) elif frame_info_actual_len . value == sizeof ( FrameInfoStruct ): frame_info_actual = FrameInfoStruct . from_buffer ( frame_info ) else : from wyzecam.tutk.tutk_protocol import TutkWyzeProtocolError raise TutkWyzeProtocolError ( f \"Unknown frame info structure format! len= { frame_info_actual_len } \" ) return ( 0 , frame_data_actual , frame_info_actual , frame_index . value , )","title":"av_recv_frame_data()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.av_recv_io_ctrl","text":"Receive AV IO control. This function is used by AV servers or AV clients to receive a AV IO control. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required av_chan_id c_int The channel ID of the AV channel to be stopped required timeout_ms int the number of milliseconds to wait before timing out required Returns: Type Description Tuple[int, int, Optional[List[bytes]]] a tuple of (the length of the io_ctrl received (or error number), the io_ctrl_type, and the data in bytes) Source code in wyzecam/tutk/tutk.py def av_recv_io_ctrl ( tutk_platform_lib : CDLL , av_chan_id : c_int , timeout_ms : int ) -> typing . Tuple [ int , int , Optional [ typing . List [ bytes ]]]: \"\"\"Receive AV IO control. This function is used by AV servers or AV clients to receive a AV IO control. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param av_chan_id: The channel ID of the AV channel to be stopped :param timeout_ms: the number of milliseconds to wait before timing out :returns: a tuple of (the length of the io_ctrl received (or error number), the io_ctrl_type, and the data in bytes) \"\"\" pn_io_ctrl_type = c_uint () ctl_data_len = 1024 * 1024 ctl_data = ( c_char * ctl_data_len )() actual_len = tutk_platform_lib . avRecvIOCtrl ( av_chan_id , pointer ( pn_io_ctrl_type ), ctl_data , c_int ( ctl_data_len ), c_int ( timeout_ms ), ) return ( actual_len , pn_io_ctrl_type . value , ctl_data [ 0 : actual_len ] if actual_len > 0 else None , )","title":"av_recv_io_ctrl()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_connect_by_uid","text":"Used by a client to connect a device. This function is for a client to connect a device by specifying the UID of that device. If connection is established with the help of IOTC servers, the IOTC session ID will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required p2p_id str The UID of a device that client wants to connect required Returns: Type Description c_int IOTC session ID if return value >= 0, error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_connect_by_uid ( tutk_platform_lib : CDLL , p2p_id : str ) -> c_int : \"\"\"Used by a client to connect a device. This function is for a client to connect a device by specifying the UID of that device. If connection is established with the help of IOTC servers, the IOTC session ID will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param p2p_id: The UID of a device that client wants to connect :return: IOTC session ID if return value >= 0, error code if return value < 0 \"\"\" session_id : c_int = tutk_platform_lib . IOTC_Connect_ByUID ( c_char_p ( p2p_id . encode ( \"ascii\" )) ) return session_id","title":"iotc_connect_by_uid()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_connect_by_uid_parallel","text":"Used by a client to connect a device and bind to a specified session ID. This function is for a client to connect a device by specifying the UID of that device, and bind to a tutk_platform_free session ID from IOTC_Get_SessionID(). If connection is established with the help of IOTC servers, the IOTC_ER_NoERROR will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. If this function is called by multiple threads, the connections will be processed concurrently. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required p2p_id str The UID of a device that client wants to connect required session_id c_int The Session ID got from IOTC_Get_SessionID() the connection should bind to. required Returns: Type Description c_int IOTC session ID if return value >= 0, error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_connect_by_uid_parallel ( tutk_platform_lib : CDLL , p2p_id : str , session_id : c_int ) -> c_int : \"\"\"Used by a client to connect a device and bind to a specified session ID. This function is for a client to connect a device by specifying the UID of that device, and bind to a tutk_platform_free session ID from IOTC_Get_SessionID(). If connection is established with the help of IOTC servers, the IOTC_ER_NoERROR will be returned in this function and then device and client can communicate for the other later by using this IOTC session ID. If this function is called by multiple threads, the connections will be processed concurrently. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param p2p_id: The UID of a device that client wants to connect :param session_id: The Session ID got from IOTC_Get_SessionID() the connection should bind to. :return: IOTC session ID if return value >= 0, error code if return value < 0 \"\"\" resultant_session_id : c_int = tutk_platform_lib . IOTC_Connect_ByUID_Parallel ( c_char_p ( p2p_id . encode ( \"ascii\" )), session_id ) return resultant_session_id","title":"iotc_connect_by_uid_parallel()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_connect_stop_by_session_id","text":"Used by a client to stop a specific session connecting a device. This function is for a client to stop connecting a device. Since IOTC_Connect_ByUID_Parallel() is a block processes, that means the client will have to wait for the return of these functions before executing sequential instructions. In some cases, users may want the client to stop connecting immediately by this function in another thread before the return of connection process. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required session_id c_int The Session ID got from IOTC_Get_SessionID() the connection should bind to. required Returns: Type Description c_int Error code if return value < 0, otherwise 0 if successful Source code in wyzecam/tutk/tutk.py def iotc_connect_stop_by_session_id ( tutk_platform_lib : CDLL , session_id : c_int ) -> c_int : \"\"\" Used by a client to stop a specific session connecting a device. This function is for a client to stop connecting a device. Since IOTC_Connect_ByUID_Parallel() is a block processes, that means the client will have to wait for the return of these functions before executing sequential instructions. In some cases, users may want the client to stop connecting immediately by this function in another thread before the return of connection process. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param session_id: The Session ID got from IOTC_Get_SessionID() the connection should bind to. :return: Error code if return value < 0, otherwise 0 if successful \"\"\" errno : c_int = tutk_platform_lib . IOTC_Connect_Stop_BySID ( session_id ) return errno","title":"iotc_connect_stop_by_session_id()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_deinitialize","text":"Deinitialize IOTC module. This function will deinitialize IOTC module. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required Returns: Type Description c_int Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_deinitialize ( tutk_platform_lib : CDLL ) -> c_int : \"\"\"Deinitialize IOTC module. This function will deinitialize IOTC module. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :return: Error code if return value < 0 \"\"\" errno : c_int = tutk_platform_lib . IOTC_DeInitialize () return errno","title":"iotc_deinitialize()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_get_session_id","text":"Used by a client to get a tutk_platform_free session ID. This function is for a client to get a tutk_platform_free session ID used for a parameter of iotc_connect_by_uid_parallel() Source code in wyzecam/tutk/tutk.py def iotc_get_session_id ( tutk_platform_lib : CDLL ) -> c_int : \"\"\"Used by a client to get a tutk_platform_free session ID. This function is for a client to get a tutk_platform_free session ID used for a parameter of iotc_connect_by_uid_parallel() \"\"\" session_id : c_int = tutk_platform_lib . IOTC_Get_SessionID () return session_id","title":"iotc_get_session_id()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_get_version","text":"Get the version of IOTC module. This function returns the version of IOTC module. Source code in wyzecam/tutk/tutk.py def iotc_get_version ( tutk_platform_lib : CDLL ) -> int : \"\"\"Get the version of IOTC module. This function returns the version of IOTC module. \"\"\" version = c_uint32 () tutk_platform_lib . IOTC_Get_Version ( pointer ( version )) return version . value","title":"iotc_get_version()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_initialize","text":"Initialize IOTC module. This function is used by devices or clients to initialize IOTC module and shall be called before any IOTC module related function is invoked except for IOTC_Set_Max_Session_Number(). The different between this function and IOTC_Initialize() is this function uses following steps to connect masters (1) IP addresses of master (2) if fails to connect in step 1, resolve predefined domain name of masters (3) try to connect again with the resolved IP address of step 2 if IP is resolved successfully. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required udp_port int Specify a UDP port. Random UDP port is used if it is specified as 0. 0 Returns: Type Description int 0 if successful, Error code if return value < 0 Source code in wyzecam/tutk/tutk.py def iotc_initialize ( tutk_platform_lib : CDLL , udp_port : int = 0 ) -> int : \"\"\"Initialize IOTC module. This function is used by devices or clients to initialize IOTC module and shall be called before any IOTC module related function is invoked except for IOTC_Set_Max_Session_Number(). The different between this function and IOTC_Initialize() is this function uses following steps to connect masters (1) IP addresses of master (2) if fails to connect in step 1, resolve predefined domain name of masters (3) try to connect again with the resolved IP address of step 2 if IP is resolved successfully. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param udp_port: Specify a UDP port. Random UDP port is used if it is specified as 0. :return: 0 if successful, Error code if return value < 0 \"\"\" errno : int = tutk_platform_lib . IOTC_Initialize2 ( udp_port ) return errno","title":"iotc_initialize()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_session_check","text":"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. Parameters: Name Type Description Default tutk_platform_lib CDLL The underlying c library (from tutk.load_library()) required session_id c_int The session ID of the IOTC session to be checked required Returns: Type Description Tuple[int, wyzecam.tutk.tutk.SInfoStruct] The session info of specified IOTC session Source code in wyzecam/tutk/tutk.py def iotc_session_check ( tutk_platform_lib : CDLL , session_id : c_int ) -> typing . Tuple [ int , SInfoStruct ]: \"\"\"Used by a device or a client to check the IOTC session info. A device or a client may use this function to check if the IOTC session is still alive as well as getting the IOTC session info. :param tutk_platform_lib: The underlying c library (from tutk.load_library()) :param session_id: The session ID of the IOTC session to be checked :return: The session info of specified IOTC session \"\"\" sess_info = SInfoStruct () err_code = tutk_platform_lib . IOTC_Session_Check ( session_id , pointer ( sess_info ) ) return err_code , sess_info","title":"iotc_session_check()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_session_close","text":"Used by a device or a client to close a IOTC session. A device or a client uses this function to close a IOTC session specified by its session ID if this IOTC session is no longer required. Parameters: Name Type Description Default tutk_platform_lib CDLL the c library loaded from the 'load_library' call. required session_id c_int The session ID of the IOTC session to start AV client required Source code in wyzecam/tutk/tutk.py def iotc_session_close ( tutk_platform_lib : CDLL , session_id : c_int ) -> None : \"\"\"Used by a device or a client to close a IOTC session. A device or a client uses this function to close a IOTC session specified by its session ID if this IOTC session is no longer required. :param tutk_platform_lib: the c library loaded from the 'load_library' call. :param session_id: The session ID of the IOTC session to start AV client \"\"\" tutk_platform_lib . IOTC_Session_Close ( session_id )","title":"iotc_session_close()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.iotc_set_log_path","text":"Set path of log file. Set the absolute path of log file Source code in wyzecam/tutk/tutk.py def iotc_set_log_path ( tutk_platform_lib : CDLL , path : str ) -> None : \"\"\"Set path of log file. Set the absolute path of log file \"\"\" tutk_platform_lib . IOTC_Set_Log_Path ( c_char_p ( path . encode ( \"ascii\" )), c_int ( 0 ) )","title":"iotc_set_log_path()"},{"location":"reference/tutk/tutk/#wyzecam.tutk.tutk.load_library","text":"Load the underlying iotc library Parameters: Name Type Description Default shared_lib_path Optional[str] the path to the shared library libIOTCAPIs_ALL None Returns: Type Description CDLL the tutk_platform_lib, suitable for passing to other functions in this module Source code in wyzecam/tutk/tutk.py def load_library ( shared_lib_path : Optional [ str ] = None , ) -> CDLL : \"\"\"Load the underlying iotc library :param shared_lib_path: the path to the shared library libIOTCAPIs_ALL :return: the tutk_platform_lib, suitable for passing to other functions in this module \"\"\" if shared_lib_path is None : if pathlib . Path ( \"/usr/local/lib/libIOTCAPIs_ALL.dylib\" ) . exists (): shared_lib_path = \"/usr/local/lib/libIOTCAPIs_ALL.dylib\" if pathlib . Path ( \"/usr/local/lib/libIOTCAPIs_ALL.so\" ) . exists (): shared_lib_path = \"/usr/local/lib/libIOTCAPIs_ALL.so\" if shared_lib_path is None : raise RuntimeError ( \"Could not find libIOTCAPIs_ALL shared library. See documentation, \" \"or specify the full path as an argument to load_library().\" ) return cdll . LoadLibrary ( shared_lib_path )","title":"load_library()"},{"location":"reference/tutk/tutk_ioctl_mux/","text":"tutk_ioctl_mux.py TutkIOCtrlMux An \"IO Ctrl\" interface for sending and receiving data over a control channel built into an IOTC session with a particular device. Use this to send and receive configuration data from the camera. There are many, many commands supported by the wyze camera over this interface, though just a fraction of them have been reverse engineered at this point. See TutkWyzeProtocolMessage and its subclasses for the supported commands. This channel is used to authenticate the client with the camera prior to streaming audio or video data. See: wyzecam.iotc.WyzeIOTCSession.iotctrl_mux Methods __init__ ( self , tutk_platform_lib , av_chan_id ) special Initialize the mux channel. Parameters: Name Type Description Default tutk_platform_lib CDLL the underlying c library used to communicate with the wyze device; see tutk.load_library . required av_chan_id c_int the channel id of the session this mux is created on. required Source code in wyzecam/tutk/tutk_ioctl_mux.py def __init__ ( self , tutk_platform_lib : CDLL , av_chan_id : c_int ) -> None : \"\"\"Initialize the mux channel. :param tutk_platform_lib: the underlying c library used to communicate with the wyze device; see [tutk.load_library][wyzecam.tutk.tutk.load_library]. :param av_chan_id: the channel id of the session this mux is created on. \"\"\" self . tutk_platform_lib = tutk_platform_lib self . av_chan_id = av_chan_id self . queues : DefaultDict [ Union [ str , int ], \"Queue[Union[object, Tuple[int, int, int, bytes]]]\" ] = defaultdict ( Queue ) self . listener = TutkIOCtrlMuxListener ( tutk_platform_lib , av_chan_id , self . queues ) send_ioctl ( self , msg , ctrl_type = 256 ) Send a TutkWyzeProtocolMessage to the camera. This should be called after the listener has been started, by using the mux as a context manager: with session . ioctrl_mux () as mux : result = mux . send_ioctl ( msg ) Parameters: Name Type Description Default msg TutkWyzeProtocolMessage The message to send to the client. See tutk_protocol.py Commands required ctrl_type int used internally by the iotc library, should always be tutk.IOTYPE_USER_DEFINED_START . 256 Returns: Type Description TutkIOCtrlFuture a future promise of a response from the camera. See wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture Source code in wyzecam/tutk/tutk_ioctl_mux.py def send_ioctl ( self , msg : TutkWyzeProtocolMessage , ctrl_type : int = tutk . IOTYPE_USER_DEFINED_START , ) -> TutkIOCtrlFuture : \"\"\" Send a [TutkWyzeProtocolMessage][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage] to the camera. This should be called after the listener has been started, by using the mux as a context manager: ```python with session.ioctrl_mux() as mux: result = mux.send_ioctl(msg) ``` :param msg: The message to send to the client. See [tutk_protocol.py Commands](../tutk_protocol_commands/) :param ctrl_type: used internally by the iotc library, should always be `tutk.IOTYPE_USER_DEFINED_START`. :returns: a future promise of a response from the camera. See [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture][] \"\"\" encoded_msg = msg . encode () encoded_msg_header = ( tutk_protocol . TutkWyzeProtocolHeader . from_buffer_copy ( encoded_msg [ 0 : 16 ] ) ) logger . debug ( \"SEND %s %s %s \" , msg , encoded_msg_header , encoded_msg [ 16 :]) errcode = tutk . av_send_io_ctrl ( self . tutk_platform_lib , self . av_chan_id , ctrl_type , encoded_msg ) if errcode : return TutkIOCtrlFuture ( msg , errcode = errcode ) if not msg . expected_response_code : logger . warning ( \"no expected response code found\" ) return TutkIOCtrlFuture ( msg ) return TutkIOCtrlFuture ( msg , self . queues [ msg . expected_response_code ]) start_listening ( self ) Start a separate thread listening for responses from the camera. This is generally called by using the TutkIOCtrlMux as a context manager: with session . ioctrl_mux () as mux : ... If this method is called explicitly, remember to call stop_listening when finished. See: wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.stop_listening Source code in wyzecam/tutk/tutk_ioctl_mux.py def start_listening ( self ) -> None : \"\"\"Start a separate thread listening for responses from the camera. This is generally called by using the TutkIOCtrlMux as a context manager: ```python with session.ioctrl_mux() as mux: ... ``` If this method is called explicitly, remember to call `stop_listening` when finished. See: [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.stop_listening][] \"\"\" self . listener . start () stop_listening ( self ) Shuts down the separate thread used for listening for responses to the camera See: wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.start_listening Source code in wyzecam/tutk/tutk_ioctl_mux.py def stop_listening ( self ) -> None : \"\"\" Shuts down the separate thread used for listening for responses to the camera See: [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.start_listening][] \"\"\" self . queues [ CONTROL_CHANNEL ] . put ( STOP_SENTINEL ) self . listener . join () waitfor ( self , futures , timeout = None ) Wait for the responses of one or more TutkIOCtrlFuture s. with session . ioctrl_mux () as mux : f1 = mux . send_ioctl ( msg ) f2 = mux . send_ioctl ( msg2 ) resp1 , resp2 = mux . waitfor ([ f1 , f2 ]) This allows you to wait for a set of TutkIOCtrlFuture s to respond in any order, and allows you to send multiple commands to the camera without waiting for each one to return before sending another. If you are sending one command at a time, consider using TutkIOCtrlFuture.result() directly: with session . ioctrl_mux () as mux : f1 = mux . send_ioctl ( msg ) resp1 = f1 . result () f2 = mux . send_ioctl ( msg2 ) resp2 = f2 . result () Source code in wyzecam/tutk/tutk_ioctl_mux.py def waitfor ( self , futures : Union [ TutkIOCtrlFuture , List [ TutkIOCtrlFuture ]], timeout : Optional [ int ] = None , ) -> Union [ Any , List [ Any ]]: \"\"\"Wait for the responses of one or more `TutkIOCtrlFuture`s. ```python with session.ioctrl_mux() as mux: f1 = mux.send_ioctl(msg) f2 = mux.send_ioctl(msg2) resp1, resp2 = mux.waitfor([f1, f2]) ``` This allows you to wait for a set of `TutkIOCtrlFuture`s to respond in any order, and allows you to send multiple commands to the camera without waiting for each one to return before sending another. If you are sending one command at a time, consider using `TutkIOCtrlFuture.result()` directly: ```python with session.ioctrl_mux() as mux: f1 = mux.send_ioctl(msg) resp1 = f1.result() f2 = mux.send_ioctl(msg2) resp2 = f2.result() ``` \"\"\" unwrap_single_item = False if isinstance ( futures , TutkIOCtrlFuture ): futures = [ futures ] unwrap_single_item = True results = [ None ] * len ( futures ) start = time . time () while ( timeout is None or time . time () - start <= timeout ) and any ( result is None for result in results ): all_success = True for i , future in enumerate ( futures ): if results [ i ] is not None : continue try : result = future . result ( block = False ) results [ i ] = result except Empty : all_success = False # if we don't get all of them this pass, wait a short period before checking again if not all_success : time . sleep ( 0.1 ) if unwrap_single_item : return results [ 0 ] else : return results TutkIOCtrlMuxListener Methods run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in wyzecam/tutk/tutk_ioctl_mux.py def run ( self ) -> None : timeout_ms = 1000 logger . info ( f \"Now listening on channel id { self . av_chan_id } \" ) while True : try : control_channel_command = self . queues [ CONTROL_CHANNEL ] . get_nowait () if control_channel_command == STOP_SENTINEL : logger . info ( f \"No longer listening on channel id { self . av_chan_id } \" ) return except Empty : pass actual_len , io_ctl_type , data = tutk . av_recv_io_ctrl ( self . tutk_platform_lib , self . av_chan_id , timeout_ms ) if actual_len == tutk . AV_ER_TIMEOUT : continue elif actual_len == tutk . AV_ER_SESSION_CLOSE_BY_REMOTE : logger . warning ( \"Connection closed by remote. Closing connection.\" ) break elif actual_len < 0 : raise tutk . TutkError ( actual_len ) header , payload = tutk_protocol . decode ( data ) logger . debug ( f \"RECV { header } : { repr ( payload ) } \" ) self . queues [ header . code ] . put ( ( actual_len , io_ctl_type , header . protocol , payload ) ) TutkIOCtrlFuture Holds the result of a message sent over a TutkIOCtrlMux; a TutkIOCtrlFuture is returned by [TutkIOCtrlMux.send_ioctl][wyzecam.tutk.tutk_ioctrl_mox.TutkIOCtrlMux.send_ioctl] , and represents the value of a future response from the camera. The actual contents of this response should be retrieved by calling result() , below. Attributes: Name Type Description req TutkWyzeProtocolMessage The message sent to the camera that we are waiting for a response from errcode Optional[c_int] The resultant error code associated with this response resp_protocol Optional[int] The 2-byte protocol version of the header of the response resp_data Optional[bytes] The raw message sent from the camera to the client Methods result ( self , block = True , timeout = 10000 ) Wait until the camera has responded to our message, and return the result. Parameters: Name Type Description Default block bool wait until the camera has responded, or the timeout has been reached. if False, returns immediately if we have already recieved a response, otherwise raise queue.Empty. True timeout int the maximum number of milliseconds to wait for the response from the camera, after which queue.Empty will be raised. 10000 Returns: Type Description Optional[Any] the result of TutkWyzeProtocolMessage.parse_response for the appropriate message. Source code in wyzecam/tutk/tutk_ioctl_mux.py def result ( self , block : bool = True , timeout : int = 10000 ) -> Optional [ Any ]: \"\"\" Wait until the camera has responded to our message, and return the result. :param block: wait until the camera has responded, or the timeout has been reached. if False, returns immediately if we have already recieved a response, otherwise raise queue.Empty. :param timeout: the maximum number of milliseconds to wait for the response from the camera, after which queue.Empty will be raised. :returns: the result of [`TutkWyzeProtocolMessage.parse_response`][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage.parse_response] for the appropriate message. \"\"\" if self . resp_data is not None : return self . req . parse_response ( self . resp_data ) if self . errcode : raise tutk . TutkError ( self . errcode ) if self . expected_response_code is None : logger . warning ( \"no response code!\" ) return None assert self . queue is not None , \"Future created without error nor queue!\" msg = self . queue . get ( block = block , timeout = timeout ) assert isinstance ( msg , tuple ), \"Expected a iotc result, instead got sentinel!\" actual_len , io_ctl_type , resp_protocol , data = msg if actual_len < 0 : raise tutk . TutkError ( self . errcode ) self . io_ctl_type = io_ctl_type self . resp_protocol = resp_protocol self . resp_data = data return self . req . parse_response ( data )","title":"tutk_ioctl_mux.py"},{"location":"reference/tutk/tutk_ioctl_mux/#tutk_ioctl_muxpy","text":"","title":"tutk_ioctl_mux.py"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux","text":"An \"IO Ctrl\" interface for sending and receiving data over a control channel built into an IOTC session with a particular device. Use this to send and receive configuration data from the camera. There are many, many commands supported by the wyze camera over this interface, though just a fraction of them have been reverse engineered at this point. See TutkWyzeProtocolMessage and its subclasses for the supported commands. This channel is used to authenticate the client with the camera prior to streaming audio or video data. See: wyzecam.iotc.WyzeIOTCSession.iotctrl_mux","title":"TutkIOCtrlMux"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.__init__","text":"Initialize the mux channel. Parameters: Name Type Description Default tutk_platform_lib CDLL the underlying c library used to communicate with the wyze device; see tutk.load_library . required av_chan_id c_int the channel id of the session this mux is created on. required Source code in wyzecam/tutk/tutk_ioctl_mux.py def __init__ ( self , tutk_platform_lib : CDLL , av_chan_id : c_int ) -> None : \"\"\"Initialize the mux channel. :param tutk_platform_lib: the underlying c library used to communicate with the wyze device; see [tutk.load_library][wyzecam.tutk.tutk.load_library]. :param av_chan_id: the channel id of the session this mux is created on. \"\"\" self . tutk_platform_lib = tutk_platform_lib self . av_chan_id = av_chan_id self . queues : DefaultDict [ Union [ str , int ], \"Queue[Union[object, Tuple[int, int, int, bytes]]]\" ] = defaultdict ( Queue ) self . listener = TutkIOCtrlMuxListener ( tutk_platform_lib , av_chan_id , self . queues )","title":"__init__()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.send_ioctl","text":"Send a TutkWyzeProtocolMessage to the camera. This should be called after the listener has been started, by using the mux as a context manager: with session . ioctrl_mux () as mux : result = mux . send_ioctl ( msg ) Parameters: Name Type Description Default msg TutkWyzeProtocolMessage The message to send to the client. See tutk_protocol.py Commands required ctrl_type int used internally by the iotc library, should always be tutk.IOTYPE_USER_DEFINED_START . 256 Returns: Type Description TutkIOCtrlFuture a future promise of a response from the camera. See wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture Source code in wyzecam/tutk/tutk_ioctl_mux.py def send_ioctl ( self , msg : TutkWyzeProtocolMessage , ctrl_type : int = tutk . IOTYPE_USER_DEFINED_START , ) -> TutkIOCtrlFuture : \"\"\" Send a [TutkWyzeProtocolMessage][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage] to the camera. This should be called after the listener has been started, by using the mux as a context manager: ```python with session.ioctrl_mux() as mux: result = mux.send_ioctl(msg) ``` :param msg: The message to send to the client. See [tutk_protocol.py Commands](../tutk_protocol_commands/) :param ctrl_type: used internally by the iotc library, should always be `tutk.IOTYPE_USER_DEFINED_START`. :returns: a future promise of a response from the camera. See [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture][] \"\"\" encoded_msg = msg . encode () encoded_msg_header = ( tutk_protocol . TutkWyzeProtocolHeader . from_buffer_copy ( encoded_msg [ 0 : 16 ] ) ) logger . debug ( \"SEND %s %s %s \" , msg , encoded_msg_header , encoded_msg [ 16 :]) errcode = tutk . av_send_io_ctrl ( self . tutk_platform_lib , self . av_chan_id , ctrl_type , encoded_msg ) if errcode : return TutkIOCtrlFuture ( msg , errcode = errcode ) if not msg . expected_response_code : logger . warning ( \"no expected response code found\" ) return TutkIOCtrlFuture ( msg ) return TutkIOCtrlFuture ( msg , self . queues [ msg . expected_response_code ])","title":"send_ioctl()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.start_listening","text":"Start a separate thread listening for responses from the camera. This is generally called by using the TutkIOCtrlMux as a context manager: with session . ioctrl_mux () as mux : ... If this method is called explicitly, remember to call stop_listening when finished. See: wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.stop_listening Source code in wyzecam/tutk/tutk_ioctl_mux.py def start_listening ( self ) -> None : \"\"\"Start a separate thread listening for responses from the camera. This is generally called by using the TutkIOCtrlMux as a context manager: ```python with session.ioctrl_mux() as mux: ... ``` If this method is called explicitly, remember to call `stop_listening` when finished. See: [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.stop_listening][] \"\"\" self . listener . start ()","title":"start_listening()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.stop_listening","text":"Shuts down the separate thread used for listening for responses to the camera See: wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.start_listening Source code in wyzecam/tutk/tutk_ioctl_mux.py def stop_listening ( self ) -> None : \"\"\" Shuts down the separate thread used for listening for responses to the camera See: [wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.start_listening][] \"\"\" self . queues [ CONTROL_CHANNEL ] . put ( STOP_SENTINEL ) self . listener . join ()","title":"stop_listening()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux.waitfor","text":"Wait for the responses of one or more TutkIOCtrlFuture s. with session . ioctrl_mux () as mux : f1 = mux . send_ioctl ( msg ) f2 = mux . send_ioctl ( msg2 ) resp1 , resp2 = mux . waitfor ([ f1 , f2 ]) This allows you to wait for a set of TutkIOCtrlFuture s to respond in any order, and allows you to send multiple commands to the camera without waiting for each one to return before sending another. If you are sending one command at a time, consider using TutkIOCtrlFuture.result() directly: with session . ioctrl_mux () as mux : f1 = mux . send_ioctl ( msg ) resp1 = f1 . result () f2 = mux . send_ioctl ( msg2 ) resp2 = f2 . result () Source code in wyzecam/tutk/tutk_ioctl_mux.py def waitfor ( self , futures : Union [ TutkIOCtrlFuture , List [ TutkIOCtrlFuture ]], timeout : Optional [ int ] = None , ) -> Union [ Any , List [ Any ]]: \"\"\"Wait for the responses of one or more `TutkIOCtrlFuture`s. ```python with session.ioctrl_mux() as mux: f1 = mux.send_ioctl(msg) f2 = mux.send_ioctl(msg2) resp1, resp2 = mux.waitfor([f1, f2]) ``` This allows you to wait for a set of `TutkIOCtrlFuture`s to respond in any order, and allows you to send multiple commands to the camera without waiting for each one to return before sending another. If you are sending one command at a time, consider using `TutkIOCtrlFuture.result()` directly: ```python with session.ioctrl_mux() as mux: f1 = mux.send_ioctl(msg) resp1 = f1.result() f2 = mux.send_ioctl(msg2) resp2 = f2.result() ``` \"\"\" unwrap_single_item = False if isinstance ( futures , TutkIOCtrlFuture ): futures = [ futures ] unwrap_single_item = True results = [ None ] * len ( futures ) start = time . time () while ( timeout is None or time . time () - start <= timeout ) and any ( result is None for result in results ): all_success = True for i , future in enumerate ( futures ): if results [ i ] is not None : continue try : result = future . result ( block = False ) results [ i ] = result except Empty : all_success = False # if we don't get all of them this pass, wait a short period before checking again if not all_success : time . sleep ( 0.1 ) if unwrap_single_item : return results [ 0 ] else : return results","title":"waitfor()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMuxListener","text":"","title":"TutkIOCtrlMuxListener"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMuxListener-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMuxListener.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in wyzecam/tutk/tutk_ioctl_mux.py def run ( self ) -> None : timeout_ms = 1000 logger . info ( f \"Now listening on channel id { self . av_chan_id } \" ) while True : try : control_channel_command = self . queues [ CONTROL_CHANNEL ] . get_nowait () if control_channel_command == STOP_SENTINEL : logger . info ( f \"No longer listening on channel id { self . av_chan_id } \" ) return except Empty : pass actual_len , io_ctl_type , data = tutk . av_recv_io_ctrl ( self . tutk_platform_lib , self . av_chan_id , timeout_ms ) if actual_len == tutk . AV_ER_TIMEOUT : continue elif actual_len == tutk . AV_ER_SESSION_CLOSE_BY_REMOTE : logger . warning ( \"Connection closed by remote. Closing connection.\" ) break elif actual_len < 0 : raise tutk . TutkError ( actual_len ) header , payload = tutk_protocol . decode ( data ) logger . debug ( f \"RECV { header } : { repr ( payload ) } \" ) self . queues [ header . code ] . put ( ( actual_len , io_ctl_type , header . protocol , payload ) )","title":"run()"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture","text":"Holds the result of a message sent over a TutkIOCtrlMux; a TutkIOCtrlFuture is returned by [TutkIOCtrlMux.send_ioctl][wyzecam.tutk.tutk_ioctrl_mox.TutkIOCtrlMux.send_ioctl] , and represents the value of a future response from the camera. The actual contents of this response should be retrieved by calling result() , below. Attributes: Name Type Description req TutkWyzeProtocolMessage The message sent to the camera that we are waiting for a response from errcode Optional[c_int] The resultant error code associated with this response resp_protocol Optional[int] The 2-byte protocol version of the header of the response resp_data Optional[bytes] The raw message sent from the camera to the client","title":"TutkIOCtrlFuture"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_ioctl_mux/#wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlFuture.result","text":"Wait until the camera has responded to our message, and return the result. Parameters: Name Type Description Default block bool wait until the camera has responded, or the timeout has been reached. if False, returns immediately if we have already recieved a response, otherwise raise queue.Empty. True timeout int the maximum number of milliseconds to wait for the response from the camera, after which queue.Empty will be raised. 10000 Returns: Type Description Optional[Any] the result of TutkWyzeProtocolMessage.parse_response for the appropriate message. Source code in wyzecam/tutk/tutk_ioctl_mux.py def result ( self , block : bool = True , timeout : int = 10000 ) -> Optional [ Any ]: \"\"\" Wait until the camera has responded to our message, and return the result. :param block: wait until the camera has responded, or the timeout has been reached. if False, returns immediately if we have already recieved a response, otherwise raise queue.Empty. :param timeout: the maximum number of milliseconds to wait for the response from the camera, after which queue.Empty will be raised. :returns: the result of [`TutkWyzeProtocolMessage.parse_response`][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage.parse_response] for the appropriate message. \"\"\" if self . resp_data is not None : return self . req . parse_response ( self . resp_data ) if self . errcode : raise tutk . TutkError ( self . errcode ) if self . expected_response_code is None : logger . warning ( \"no response code!\" ) return None assert self . queue is not None , \"Future created without error nor queue!\" msg = self . queue . get ( block = block , timeout = timeout ) assert isinstance ( msg , tuple ), \"Expected a iotc result, instead got sentinel!\" actual_len , io_ctl_type , resp_protocol , data = msg if actual_len < 0 : raise tutk . TutkError ( self . errcode ) self . io_ctl_type = io_ctl_type self . resp_protocol = resp_protocol self . resp_data = data return self . req . parse_response ( data )","title":"result()"},{"location":"reference/tutk/tutk_protocol/","text":"tutk_protocol.py TutkWyzeProtocolHeader Struct representing the first 16 bytes of messages sent back and forth between the camera and a client over a TutkIOCtrlMux . Attributes: Name Type Description prefix str the first two bytes of the header, always HL . protocol int the protocol version being spoken by the client or camera. This varies quite a bit depending on the firmware version of the camera. code int The 2-byte \"command\" being issued, either by the camera, or the client. By convention, it appears commands sent from a client to the camera are even numbered 'codes', whereas responses from the camera back to the client are always odd. txt_len int the length of the payload of the message, i.e. the contents just after this header TutkWyzeProtocolMessage An abstract class representing a command sent from the client to the camera. Subclasses implement particular codes. Attributes: Name Type Description code int the 2 digit code representing this message expected_response_code Optional[int] the code of the message expected to be the 'response' to this one, from the camera. Methods encode ( self ) Translates this protocol message into a series of bytes, including the appropriate 16 byte header . Source code in wyzecam/tutk/tutk_protocol.py def encode ( self ) -> bytes : \"\"\" Translates this protocol message into a series of bytes, including the appropriate [16 byte header][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolHeader]. \"\"\" return encode ( self . code , 0 , None ) parse_response ( self , resp_data ) Called by TutkIOCtrlMux upon receipt of the corresponding expected_response_code of this message. Source code in wyzecam/tutk/tutk_protocol.py def parse_response ( self , resp_data : bytes ) -> typing . Any : \"\"\" Called by [TutkIOCtrlMux][wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux] upon receipt of the corresponding [expected_response_code][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage] of this message. \"\"\" return resp_data","title":"Classes"},{"location":"reference/tutk/tutk_protocol/#tutk_protocolpy","text":"","title":"tutk_protocol.py"},{"location":"reference/tutk/tutk_protocol/#wyzecam.tutk.tutk_protocol.TutkWyzeProtocolHeader","text":"Struct representing the first 16 bytes of messages sent back and forth between the camera and a client over a TutkIOCtrlMux . Attributes: Name Type Description prefix str the first two bytes of the header, always HL . protocol int the protocol version being spoken by the client or camera. This varies quite a bit depending on the firmware version of the camera. code int The 2-byte \"command\" being issued, either by the camera, or the client. By convention, it appears commands sent from a client to the camera are even numbered 'codes', whereas responses from the camera back to the client are always odd. txt_len int the length of the payload of the message, i.e. the contents just after this header","title":"TutkWyzeProtocolHeader"},{"location":"reference/tutk/tutk_protocol/#wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage","text":"An abstract class representing a command sent from the client to the camera. Subclasses implement particular codes. Attributes: Name Type Description code int the 2 digit code representing this message expected_response_code Optional[int] the code of the message expected to be the 'response' to this one, from the camera.","title":"TutkWyzeProtocolMessage"},{"location":"reference/tutk/tutk_protocol/#wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_protocol/#wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage.encode","text":"Translates this protocol message into a series of bytes, including the appropriate 16 byte header . Source code in wyzecam/tutk/tutk_protocol.py def encode ( self ) -> bytes : \"\"\" Translates this protocol message into a series of bytes, including the appropriate [16 byte header][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolHeader]. \"\"\" return encode ( self . code , 0 , None )","title":"encode()"},{"location":"reference/tutk/tutk_protocol/#wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage.parse_response","text":"Called by TutkIOCtrlMux upon receipt of the corresponding expected_response_code of this message. Source code in wyzecam/tutk/tutk_protocol.py def parse_response ( self , resp_data : bytes ) -> typing . Any : \"\"\" Called by [TutkIOCtrlMux][wyzecam.tutk.tutk_ioctl_mux.TutkIOCtrlMux] upon receipt of the corresponding [expected_response_code][wyzecam.tutk.tutk_protocol.TutkWyzeProtocolMessage] of this message. \"\"\" return resp_data","title":"parse_response()"},{"location":"reference/tutk/tutk_protocol_commands/","text":"tutk_protocol.py Commands K10000ConnectRequest The \"connect request\" sent by a client to a camera when the client first connects. This command initiates the handshake that authenticates the client to the camera. The expected response to this command is 10001 , in which the camera provides a set of 16 random bytes for the client to sign with the 'enr' of the camera. K10002ConnectAuth The \"challenge response\" sent by a client to a camera as part of the authentication handshake when the client first connects. This command is deprecated, and is replaced by K10008ConnectUserAuth on newer devices. We need to continue supporting this for older firmwares, however. The expected response to this command is 10003 , in which the camera provides a json object with the result of the authentication exchange (and if successful, a bunch of device information). Methods __init__ ( self , challenge_response , mac , open_video = True , open_audio = True ) special Constructs a new K10002ConnectAuth message Parameters: Name Type Description Default challenge_response bytes the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. required mac str the mac address of the camera required open_video bool True if we wish to start streaming video after authentication is successful. True open_audio bool True if we wish to start streaming audio after authentication is successful. True Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , challenge_response : bytes , mac : str , open_video : bool = True , open_audio : bool = True , ) -> None : \"\"\" Constructs a new K10002ConnectAuth message :param challenge_response: the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. :param mac: the mac address of the camera :param open_video: True if we wish to start streaming video after authentication is successful. :param open_audio: True if we wish to start streaming audio after authentication is successful. \"\"\" super () . __init__ ( 10002 ) assert ( len ( challenge_response ) == 16 ), \"expected challenge response to be 16 bytes long\" if len ( mac ) < 4 : mac = mac + \"1234\" self . challenge_response = challenge_response self . username = mac self . open_video = open_video self . open_audio = open_audio K10008ConnectUserAuth The \"challenge response\" sent by a client to a camera as part of the authentication handshake when the client first connects. This command is a newer version of K10008ConnectUserAuth , and it sends the 'open_user_id' as part of the authentication response. The expected response to this command is 10009 , in which the camera provides a json object with the result of the authentication exchange (and if successful, a bunch of device information). Methods __init__ ( self , challenge_response , phone_id , open_userid , open_video = True , open_audio = True ) special Constructs a new K10008ConnectAuth message Parameters: Name Type Description Default challenge_response bytes the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. required phone_id str the phone id of the client required open_userid str the open_user_id associated with the user authenticating. required open_video bool True if we wish to start streaming video after authentication is successful. True open_audio bool True if we wish to start streaming audio after authentication is successful. True Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , challenge_response : bytes , phone_id : str , open_userid : str , open_video : bool = True , open_audio : bool = True , ) -> None : \"\"\" Constructs a new K10008ConnectAuth message :param challenge_response: the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. :param phone_id: the phone id of the client :param open_userid: the open_user_id associated with the user authenticating. :param open_video: True if we wish to start streaming video after authentication is successful. :param open_audio: True if we wish to start streaming audio after authentication is successful. \"\"\" super () . __init__ ( 10008 ) assert ( len ( challenge_response ) == 16 ), \"expected challenge response to be 16 bytes long\" if len ( phone_id ) < 4 : phone_id = phone_id + \"1234\" self . challenge_response = challenge_response self . username = phone_id self . open_userid = open_userid self . open_video = open_video self . open_audio = open_audio K10010ControlChannel A command used frequently by the mobile app to configure settings on the camera. Not terribly well understood. K10020CheckCameraInfo A command used to read the current settings of the camera. Not terribly well understood. K10056SetResolvingBit A message used to set the resolution and bitrate of the camera. This is sent automatically after the authentication handshake completes successfully. Methods __init__ ( self , frame_size = 0 , bitrate = 120 ) special Construct a K10056SetResolvingBit message, with a given frame size and bitrate. Possible frame sizes are: tutk.FRAME_SIZE_1080P : 1080P, or 1920 x 1080 tutk.FRAME_SIZE_360P : 360P, or 640 x 360 Possible bit rates are: tutk.BITRATE_360P : the bitrate chosen when selecting '360P' in the app; 30 KB/s tutk.BITRATE_SD : the bitrate chosen when selecting 'SD' in the app; 60 KB/s tutk.BITRATE_HD : the bitrate chosen when selecting 'HD' in the app; 120 KB/s tutk.BITRATE_SUPER_HD : an even higher bitrate than ever asked for by the app; 150 KB/s tutk.BITRATE_SUPER_SUPER_HD : an even higher bitrate than ever asked for by the app; 240 KB/s Parameters: Name Type Description Default frame_size the dimensions of the video to stream. 0 bitrate the bit rate, in KB/s to target in the h264/h265 encoder. 120 Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , frame_size = tutk . FRAME_SIZE_1080P , bitrate = tutk . BITRATE_HD ): \"\"\" Construct a K10056SetResolvingBit message, with a given frame size and bitrate. Possible frame sizes are: - `tutk.FRAME_SIZE_1080P`: 1080P, or 1920 x 1080 - `tutk.FRAME_SIZE_360P`: 360P, or 640 x 360 Possible bit rates are: - `tutk.BITRATE_360P`: the bitrate chosen when selecting '360P' in the app; 30 KB/s - `tutk.BITRATE_SD`: the bitrate chosen when selecting 'SD' in the app; 60 KB/s - `tutk.BITRATE_HD`: the bitrate chosen when selecting 'HD' in the app; 120 KB/s - `tutk.BITRATE_SUPER_HD`: an even higher bitrate than ever asked for by the app; 150 KB/s - `tutk.BITRATE_SUPER_SUPER_HD`: an even higher bitrate than ever asked for by the app; 240 KB/s :param frame_size: the dimensions of the video to stream. :param bitrate: the bit rate, in KB/s to target in the h264/h265 encoder. \"\"\" super () . __init__ ( 10056 ) self . frame_size = frame_size self . bitrate = bitrate K10620CheckNight A message used to check the night mode settings of the camera. Not terribly well understood. K10640GetSpotlightStatus A message used to check the spotlight settings of the camera. Not terribly well understood.","title":"Commands"},{"location":"reference/tutk/tutk_protocol_commands/#tutk_protocolpy-commands","text":"","title":"tutk_protocol.py Commands"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10000ConnectRequest","text":"The \"connect request\" sent by a client to a camera when the client first connects. This command initiates the handshake that authenticates the client to the camera. The expected response to this command is 10001 , in which the camera provides a set of 16 random bytes for the client to sign with the 'enr' of the camera.","title":"K10000ConnectRequest"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10002ConnectAuth","text":"The \"challenge response\" sent by a client to a camera as part of the authentication handshake when the client first connects. This command is deprecated, and is replaced by K10008ConnectUserAuth on newer devices. We need to continue supporting this for older firmwares, however. The expected response to this command is 10003 , in which the camera provides a json object with the result of the authentication exchange (and if successful, a bunch of device information).","title":"K10002ConnectAuth"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10002ConnectAuth-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10002ConnectAuth.__init__","text":"Constructs a new K10002ConnectAuth message Parameters: Name Type Description Default challenge_response bytes the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. required mac str the mac address of the camera required open_video bool True if we wish to start streaming video after authentication is successful. True open_audio bool True if we wish to start streaming audio after authentication is successful. True Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , challenge_response : bytes , mac : str , open_video : bool = True , open_audio : bool = True , ) -> None : \"\"\" Constructs a new K10002ConnectAuth message :param challenge_response: the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. :param mac: the mac address of the camera :param open_video: True if we wish to start streaming video after authentication is successful. :param open_audio: True if we wish to start streaming audio after authentication is successful. \"\"\" super () . __init__ ( 10002 ) assert ( len ( challenge_response ) == 16 ), \"expected challenge response to be 16 bytes long\" if len ( mac ) < 4 : mac = mac + \"1234\" self . challenge_response = challenge_response self . username = mac self . open_video = open_video self . open_audio = open_audio","title":"__init__()"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10008ConnectUserAuth","text":"The \"challenge response\" sent by a client to a camera as part of the authentication handshake when the client first connects. This command is a newer version of K10008ConnectUserAuth , and it sends the 'open_user_id' as part of the authentication response. The expected response to this command is 10009 , in which the camera provides a json object with the result of the authentication exchange (and if successful, a bunch of device information).","title":"K10008ConnectUserAuth"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10008ConnectUserAuth-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10008ConnectUserAuth.__init__","text":"Constructs a new K10008ConnectAuth message Parameters: Name Type Description Default challenge_response bytes the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. required phone_id str the phone id of the client required open_userid str the open_user_id associated with the user authenticating. required open_video bool True if we wish to start streaming video after authentication is successful. True open_audio bool True if we wish to start streaming audio after authentication is successful. True Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , challenge_response : bytes , phone_id : str , open_userid : str , open_video : bool = True , open_audio : bool = True , ) -> None : \"\"\" Constructs a new K10008ConnectAuth message :param challenge_response: the xxtea-encrypted response to the challenge bytes recieved as part of message 10001. :param phone_id: the phone id of the client :param open_userid: the open_user_id associated with the user authenticating. :param open_video: True if we wish to start streaming video after authentication is successful. :param open_audio: True if we wish to start streaming audio after authentication is successful. \"\"\" super () . __init__ ( 10008 ) assert ( len ( challenge_response ) == 16 ), \"expected challenge response to be 16 bytes long\" if len ( phone_id ) < 4 : phone_id = phone_id + \"1234\" self . challenge_response = challenge_response self . username = phone_id self . open_userid = open_userid self . open_video = open_video self . open_audio = open_audio","title":"__init__()"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10010ControlChannel","text":"A command used frequently by the mobile app to configure settings on the camera. Not terribly well understood.","title":"K10010ControlChannel"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10020CheckCameraInfo","text":"A command used to read the current settings of the camera. Not terribly well understood.","title":"K10020CheckCameraInfo"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10056SetResolvingBit","text":"A message used to set the resolution and bitrate of the camera. This is sent automatically after the authentication handshake completes successfully.","title":"K10056SetResolvingBit"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10056SetResolvingBit-methods","text":"","title":"Methods"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10056SetResolvingBit.__init__","text":"Construct a K10056SetResolvingBit message, with a given frame size and bitrate. Possible frame sizes are: tutk.FRAME_SIZE_1080P : 1080P, or 1920 x 1080 tutk.FRAME_SIZE_360P : 360P, or 640 x 360 Possible bit rates are: tutk.BITRATE_360P : the bitrate chosen when selecting '360P' in the app; 30 KB/s tutk.BITRATE_SD : the bitrate chosen when selecting 'SD' in the app; 60 KB/s tutk.BITRATE_HD : the bitrate chosen when selecting 'HD' in the app; 120 KB/s tutk.BITRATE_SUPER_HD : an even higher bitrate than ever asked for by the app; 150 KB/s tutk.BITRATE_SUPER_SUPER_HD : an even higher bitrate than ever asked for by the app; 240 KB/s Parameters: Name Type Description Default frame_size the dimensions of the video to stream. 0 bitrate the bit rate, in KB/s to target in the h264/h265 encoder. 120 Source code in wyzecam/tutk/tutk_protocol.py def __init__ ( self , frame_size = tutk . FRAME_SIZE_1080P , bitrate = tutk . BITRATE_HD ): \"\"\" Construct a K10056SetResolvingBit message, with a given frame size and bitrate. Possible frame sizes are: - `tutk.FRAME_SIZE_1080P`: 1080P, or 1920 x 1080 - `tutk.FRAME_SIZE_360P`: 360P, or 640 x 360 Possible bit rates are: - `tutk.BITRATE_360P`: the bitrate chosen when selecting '360P' in the app; 30 KB/s - `tutk.BITRATE_SD`: the bitrate chosen when selecting 'SD' in the app; 60 KB/s - `tutk.BITRATE_HD`: the bitrate chosen when selecting 'HD' in the app; 120 KB/s - `tutk.BITRATE_SUPER_HD`: an even higher bitrate than ever asked for by the app; 150 KB/s - `tutk.BITRATE_SUPER_SUPER_HD`: an even higher bitrate than ever asked for by the app; 240 KB/s :param frame_size: the dimensions of the video to stream. :param bitrate: the bit rate, in KB/s to target in the h264/h265 encoder. \"\"\" super () . __init__ ( 10056 ) self . frame_size = frame_size self . bitrate = bitrate","title":"__init__()"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10620CheckNight","text":"A message used to check the night mode settings of the camera. Not terribly well understood.","title":"K10620CheckNight"},{"location":"reference/tutk/tutk_protocol_commands/#wyzecam.tutk.tutk_protocol.K10640GetSpotlightStatus","text":"A message used to check the spotlight settings of the camera. Not terribly well understood.","title":"K10640GetSpotlightStatus"},{"location":"reference/wyze_api/wyze_api_functions/","text":"Wyze API Methods The following functions use the Wyze REST APIs to fetch the required set of data needed to authenticate with cameras locally. login ( email , password , phone_id = None ) Authenticate with Wyze This method calls out to the /user/login endpoint of auth-prod.api.wyze.com (using https), and retrieves an access token necessary to retrieve other information from the wyze server. Parameters: Name Type Description Default email str Email address used to log into wyze account required password str Password used to log into wyze account. This is used to authenticate with the wyze API server, and return a credential. required phone_id Optional[str] the ID of the device to emulate when talking to wyze. This is safe to leave as None (in which case a random phone id will be generated) None Returns: Type Description WyzeCredential a WyzeCredential with the access information, suitable for passing to get_user_info() , or get_camera_list() . Source code in wyzecam/api.py def login ( email : str , password : str , phone_id : Optional [ str ] = None ) -> WyzeCredential : \"\"\"Authenticate with Wyze This method calls out to the `/user/login` endpoint of `auth-prod.api.wyze.com` (using https), and retrieves an access token necessary to retrieve other information from the wyze server. :param email: Email address used to log into wyze account :param password: Password used to log into wyze account. This is used to authenticate with the wyze API server, and return a credential. :param phone_id: the ID of the device to emulate when talking to wyze. This is safe to leave as None (in which case a random phone id will be generated) :returns: a [WyzeCredential][wyzecam.api.WyzeCredential] with the access information, suitable for passing to [get_user_info()][wyzecam.api.get_user_info], or [get_camera_list()][wyzecam.api.get_camera_list]. \"\"\" if phone_id is None : phone_id = str ( uuid . uuid4 ()) payload = { \"email\" : email , \"password\" : triplemd5 ( password )} resp = requests . post ( \"https://auth-prod.api.wyze.com/user/login\" , json = payload , headers = get_headers ( phone_id ), ) resp . raise_for_status () return WyzeCredential . parse_obj ( dict ( resp . json (), phone_id = phone_id )) get_user_info ( auth_info ) Gets Wyze Account Information This method calls out to the /app/user/get_user_info endpoint of api.wyze.com (using https), and retrieves the account details of the authenticated user. Parameters: Name Type Description Default auth_info WyzeCredential the result of a login() call. required Returns: Type Description WyzeAccount a WyzeAccount with the user's info, suitable for passing to WyzeIOTC.connect_and_auth() . Source code in wyzecam/api.py def get_user_info ( auth_info : WyzeCredential ) -> WyzeAccount : \"\"\"Gets Wyze Account Information This method calls out to the `/app/user/get_user_info` endpoint of `api.wyze.com` (using https), and retrieves the account details of the authenticated user. :param auth_info: the result of a [`login()`][wyzecam.api.login] call. :returns: a [WyzeAccount][wyzecam.api.WyzeAccount] with the user's info, suitable for passing to [`WyzeIOTC.connect_and_auth()`][wyzecam.iotc.WyzeIOTC.connect_and_auth]. \"\"\" payload = _get_payload ( auth_info . access_token , auth_info . phone_id ) ui_headers = get_headers ( auth_info . phone_id , SCALE_USER_AGENT ) resp = requests . post ( \"https://api.wyzecam.com/app/user/get_user_info\" , json = payload , headers = ui_headers , ) resp . raise_for_status () resp_json = resp . json () assert resp_json [ \"code\" ] == \"1\" , \"Call failed\" return WyzeAccount . parse_obj ( dict ( resp_json [ \"data\" ], phone_id = auth_info . phone_id ) ) get_camera_list ( auth_info ) Source code in wyzecam/api.py def get_camera_list ( auth_info : WyzeCredential ) -> List [ WyzeCamera ]: data = get_homepage_object_list ( auth_info ) result = [] for device in data [ \"device_list\" ]: # type: Dict[str, Any] if device [ \"product_type\" ] != \"Camera\" : continue device_params = device . get ( \"device_params\" , {}) p2p_id : Optional [ str ] = device_params . get ( \"p2p_id\" ) p2p_type : Optional [ int ] = device_params . get ( \"p2p_type\" ) ip : Optional [ str ] = device_params . get ( \"ip\" ) enr : Optional [ str ] = device . get ( \"enr\" ) mac : Optional [ str ] = device . get ( \"mac\" ) product_model : Optional [ str ] = device . get ( \"product_model\" ) nickname : Optional [ str ] = device . get ( \"nickname\" ) timezone_name : Optional [ str ] = device . get ( \"timezone_name\" ) if not p2p_id : continue if not p2p_type : continue if not ip : continue if not enr : continue if not mac : continue if not product_model : continue result . append ( WyzeCamera ( p2p_id = p2p_id , p2p_type = p2p_type , ip = ip , enr = enr , mac = mac , product_model = product_model , nickname = nickname , timezone_name = timezone_name , ) ) return result","title":"Functions"},{"location":"reference/wyze_api/wyze_api_functions/#wyze-api-methods","text":"The following functions use the Wyze REST APIs to fetch the required set of data needed to authenticate with cameras locally.","title":"Wyze API Methods"},{"location":"reference/wyze_api/wyze_api_functions/#wyzecam.api.login","text":"Authenticate with Wyze This method calls out to the /user/login endpoint of auth-prod.api.wyze.com (using https), and retrieves an access token necessary to retrieve other information from the wyze server. Parameters: Name Type Description Default email str Email address used to log into wyze account required password str Password used to log into wyze account. This is used to authenticate with the wyze API server, and return a credential. required phone_id Optional[str] the ID of the device to emulate when talking to wyze. This is safe to leave as None (in which case a random phone id will be generated) None Returns: Type Description WyzeCredential a WyzeCredential with the access information, suitable for passing to get_user_info() , or get_camera_list() . Source code in wyzecam/api.py def login ( email : str , password : str , phone_id : Optional [ str ] = None ) -> WyzeCredential : \"\"\"Authenticate with Wyze This method calls out to the `/user/login` endpoint of `auth-prod.api.wyze.com` (using https), and retrieves an access token necessary to retrieve other information from the wyze server. :param email: Email address used to log into wyze account :param password: Password used to log into wyze account. This is used to authenticate with the wyze API server, and return a credential. :param phone_id: the ID of the device to emulate when talking to wyze. This is safe to leave as None (in which case a random phone id will be generated) :returns: a [WyzeCredential][wyzecam.api.WyzeCredential] with the access information, suitable for passing to [get_user_info()][wyzecam.api.get_user_info], or [get_camera_list()][wyzecam.api.get_camera_list]. \"\"\" if phone_id is None : phone_id = str ( uuid . uuid4 ()) payload = { \"email\" : email , \"password\" : triplemd5 ( password )} resp = requests . post ( \"https://auth-prod.api.wyze.com/user/login\" , json = payload , headers = get_headers ( phone_id ), ) resp . raise_for_status () return WyzeCredential . parse_obj ( dict ( resp . json (), phone_id = phone_id ))","title":"login()"},{"location":"reference/wyze_api/wyze_api_functions/#wyzecam.api.get_user_info","text":"Gets Wyze Account Information This method calls out to the /app/user/get_user_info endpoint of api.wyze.com (using https), and retrieves the account details of the authenticated user. Parameters: Name Type Description Default auth_info WyzeCredential the result of a login() call. required Returns: Type Description WyzeAccount a WyzeAccount with the user's info, suitable for passing to WyzeIOTC.connect_and_auth() . Source code in wyzecam/api.py def get_user_info ( auth_info : WyzeCredential ) -> WyzeAccount : \"\"\"Gets Wyze Account Information This method calls out to the `/app/user/get_user_info` endpoint of `api.wyze.com` (using https), and retrieves the account details of the authenticated user. :param auth_info: the result of a [`login()`][wyzecam.api.login] call. :returns: a [WyzeAccount][wyzecam.api.WyzeAccount] with the user's info, suitable for passing to [`WyzeIOTC.connect_and_auth()`][wyzecam.iotc.WyzeIOTC.connect_and_auth]. \"\"\" payload = _get_payload ( auth_info . access_token , auth_info . phone_id ) ui_headers = get_headers ( auth_info . phone_id , SCALE_USER_AGENT ) resp = requests . post ( \"https://api.wyzecam.com/app/user/get_user_info\" , json = payload , headers = ui_headers , ) resp . raise_for_status () resp_json = resp . json () assert resp_json [ \"code\" ] == \"1\" , \"Call failed\" return WyzeAccount . parse_obj ( dict ( resp_json [ \"data\" ], phone_id = auth_info . phone_id ) )","title":"get_user_info()"},{"location":"reference/wyze_api/wyze_api_functions/#wyzecam.api.get_camera_list","text":"Source code in wyzecam/api.py def get_camera_list ( auth_info : WyzeCredential ) -> List [ WyzeCamera ]: data = get_homepage_object_list ( auth_info ) result = [] for device in data [ \"device_list\" ]: # type: Dict[str, Any] if device [ \"product_type\" ] != \"Camera\" : continue device_params = device . get ( \"device_params\" , {}) p2p_id : Optional [ str ] = device_params . get ( \"p2p_id\" ) p2p_type : Optional [ int ] = device_params . get ( \"p2p_type\" ) ip : Optional [ str ] = device_params . get ( \"ip\" ) enr : Optional [ str ] = device . get ( \"enr\" ) mac : Optional [ str ] = device . get ( \"mac\" ) product_model : Optional [ str ] = device . get ( \"product_model\" ) nickname : Optional [ str ] = device . get ( \"nickname\" ) timezone_name : Optional [ str ] = device . get ( \"timezone_name\" ) if not p2p_id : continue if not p2p_type : continue if not ip : continue if not enr : continue if not mac : continue if not product_model : continue result . append ( WyzeCamera ( p2p_id = p2p_id , p2p_type = p2p_type , ip = ip , enr = enr , mac = mac , product_model = product_model , nickname = nickname , timezone_name = timezone_name , ) ) return result","title":"get_camera_list()"},{"location":"reference/wyze_api/wyze_api_models/","text":"Wyze API Methods The following objects represent data from the Wyze REST APIs: WyzeCredential pydantic-model Authenticated credentials; see wyzecam.api.login . Attributes: Name Type Description access_token str Access token used to authenticate other API calls refresh_token str Refresh token used to refresh the access_token if it expires user_id str Wyze user id of the authenticated user mfa_options Optional[Dict[str, Any]] Additional options for 2fa support mfa_details Optional[Dict[str, Any]] Additional details for 2fa support sms_session_id Optional[str] Additional details for SMS support phone_id str The phone id passed to login() WyzeAccount pydantic-model User profile information; see wyzecam.api.get_user_info . Attributes: Name Type Description phone_id str The phone id passed to login() logo str URL to a profile photo of the user nickname str nickname of the user email str email of the user user_code str code of the user user_center_id str center id of the user open_user_id str open id of the user (used for authenticating with newer firmwares; important!) WyzeCamera pydantic-model Wyze camera device information; see wyzecam.api.get_camera_list . Attributes: Name Type Description p2p_id str the p2p id of the camera, used for identifying the camera to tutk. enr str the enr of the camera, used for signing challenge requests from cameras during auth. mac str the mac address of the camera. product_model str the product model (or type) of camera camera_info Optional[Dict[str, Any]] populated as a result of authenticating with a camera using a WyzeIOTCSession . nickname Optional[str] the user specified 'nickname' of the camera timezone_name Optional[str] the timezone of the camera","title":"Models"},{"location":"reference/wyze_api/wyze_api_models/#wyze-api-methods","text":"The following objects represent data from the Wyze REST APIs:","title":"Wyze API Methods"},{"location":"reference/wyze_api/wyze_api_models/#wyzecam.api_models.WyzeCredential","text":"Authenticated credentials; see wyzecam.api.login . Attributes: Name Type Description access_token str Access token used to authenticate other API calls refresh_token str Refresh token used to refresh the access_token if it expires user_id str Wyze user id of the authenticated user mfa_options Optional[Dict[str, Any]] Additional options for 2fa support mfa_details Optional[Dict[str, Any]] Additional details for 2fa support sms_session_id Optional[str] Additional details for SMS support phone_id str The phone id passed to login()","title":"WyzeCredential"},{"location":"reference/wyze_api/wyze_api_models/#wyzecam.api_models.WyzeAccount","text":"User profile information; see wyzecam.api.get_user_info . Attributes: Name Type Description phone_id str The phone id passed to login() logo str URL to a profile photo of the user nickname str nickname of the user email str email of the user user_code str code of the user user_center_id str center id of the user open_user_id str open id of the user (used for authenticating with newer firmwares; important!)","title":"WyzeAccount"},{"location":"reference/wyze_api/wyze_api_models/#wyzecam.api_models.WyzeCamera","text":"Wyze camera device information; see wyzecam.api.get_camera_list . Attributes: Name Type Description p2p_id str the p2p id of the camera, used for identifying the camera to tutk. enr str the enr of the camera, used for signing challenge requests from cameras during auth. mac str the mac address of the camera. product_model str the product model (or type) of camera camera_info Optional[Dict[str, Any]] populated as a result of authenticating with a camera using a WyzeIOTCSession . nickname Optional[str] the user specified 'nickname' of the camera timezone_name Optional[str] the timezone of the camera","title":"WyzeCamera"}]}